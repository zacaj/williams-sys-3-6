0001   0000             #include "680xlogic.asm"
0001+  0000             ;***********************************************
0002+  0000             ;* 680X Style Logical Instruction Macros       *
0003+  0000             ;* For use with TASMx Assembler                *
0004+  0000             ;* Written by Jess M. Askey 2001 jess@askey.org*
0005+  0000             ;***********************************************
0006+  0000             .module logic
0007+  0000             
0008+  0000             var1_		.equ	$00
0009+  0000             var2_		.equ	$00
0010+  0000             var3_		.equ	$00
0011+  0000             var4_		.equ	$00
0012+  0000             
0013+  0000             #define     FLAG_IF    	0
0014+  0000             #define     FLAG_ELSE 	1
0015+  0000             #define	FLAG_BEGIN 	2
0016+  0000             
0017+  0000             ;*******************************************************************
0018+  0000             ;* Locate: Pushes two Words                                        *
0019+  0000             ;*                                                                 *
0020+  0000             ;*            Word 1 - address of branch location                  *
0021+  0000             ;*            Word 2 - Type of Operation                           *
0022+  0000             ;*                     0 - Standard ENDIF                          *
0023+  0000             ;*                     1 - ELSE or Logical ELSE                    *
0024+  0000             ;*                     2 - Loop                                    *
0025+  0000             ;*******************************************************************
0026+  0000             #define	logic_loc(type)	     \ .push  *, type
0027+  0000             
0028+  0000             ;*******************************************************************
0029+  0000             ;* Ifxx: These are the standard 'if' statements, they will always  *
0030+  0000             ;*       be of type 0.                                             *
0031+  0000             ;*******************************************************************
0032+  0000             #define	logic_ifxx(x)	     logic_loc(FLAG_IF) \ x  * 
0033+  0000             
0034+  0000             ;*******************************************************************
0035+  0000             ;* Begin: The start marker for logical loops, must terminate with  *
0036+  0000             ;*        an 'xxend' statement.                                    *
0037+  0000             ;******************************************************************* 
0038+  0000             #define     begin(x)		     logic_loc(FLAG_BEGIN)
0039+  0000             
0040+  0000             ;*******************************************************************
0041+  0000             ;* Logic End: This is the end macro for the 'begin' statement. It  *
0042+  0000             ;*            pulls the pc location of the beginning of the loop   *
0043+  0000             ;*            and verifies that the 'type' is correct.             *
0044+  0000             ;*******************************************************************
0045+  0000             #define logic_loopend(x,y)	\ .pop var1_, var2_
0046+  0000             #defcont				\#if (var1_ & FLAG_BEGIN)
0047+  0000             #defcont					\#if ((var2_-*-2+127) <= 0)
0048+  0000             #defcont						\ y	*+5
0049+  0000             #defcont						\ jmp	var2_
0050+  0000             #defcont					\#else
0051+  0000             #defcont						\ x	var2_
0052+  0000             #defcont					\#endif
0053+  0000             #defcont				\#else
0054+  0000             #defcont					\ .error "Inappropriate End for BEGIN Loop."
0055+  0000             #defcont				\#endif
0056+  0000             
0057+  0000             ;*******************************************************************
0058+  0000             ;* Logic Find: Used for ENDIF statement. Will find the pc for the  *
0059+  0000             ;*             previous IF (or ELSE) and update the branch or jump *
0060+  0000             ;*             at that address to point to the current address.    *
0061+  0000             ;*******************************************************************
0062+  0000             #define logic_end \var1_ .set *
0063+  0000             #defcont		\ .pop var3_, var4_
0064+  0000             #defcont		\#if (var3_ & FLAG_BEGIN)==0 
0065+  0000             #defcont			\#if (var3_ & FLAG_ELSE)==0	
0066+  0000             #defcont  				\var2_ .set var1_-var4_-2
0067+  0000             #defcont				\#if var2_+127 < 0
0068+  0000             #defcont					\ .error "Branch Range < -127"
0069+  0000             #defcont				\#else
0070+  0000             #defcont					\#if var2_-128 > 0
0071+  0000             #defcont						\ .error "Branch Range > 128"
0072+  0000             #defcont					\#else
0073+  0000             #defcont    					\ .org var4_+1
0074+  0000             #defcont						\ .byte var2_
0075+  0000             #defcont					\#endif
0076+  0000             #defcont				\#endif
0077+  0000             #defcont			\#else	
0078+  0000             #defcont    			\ .org  var4_-2	
0079+  0000             #defcont				\ .word var1_
0080+  0000             #defcont			\#endif
0081+  0000             #defcont			\ .org	var1_
0082+  0000             #defcont		\#else
0083+  0000             #defcont			\.error "Wrong Endtype for IF block"
0084+  0000             #defcont		\#endif
0085+  0000             
0086+  0000             ;*******************************************************************
0087+  0000             ;* Logic Else: Can act as a standard else or a complex else        *
0088+  0000             ;*             (ie. with additional logic as defined below). The   *
0089+  0000             ;*             ELSE block will resove how to terminate the current *
0090+  0000             ;*             code and then set the owning IF statement's data    *
0091+  0000             ;*             byte.                                               *
0092+  0000             ;*******************************************************************
0093+  0000             #define	logic_else(x,y)	\var1_ .set $
0094+  0000             #defcont		\ .pop var3_, var4_
0095+  0000             #defcont		\#if (var3_ & FLAG_BEGIN)==0
0096+  0000             #defcont			\#if (var3_ & FLAG_ELSE)==0
0097+  0000             #defcont				\ .org var4_+1
0098+  0000             #defcont	      		\#if x==0
0099+  0000             #defcont					\var2_ .set var1_-var4_-2+2
0100+  0000             #defcont					\#if var2_+127 < 0
0101+  0000             #defcont						\ .org var1_
0102+  0000             #defcont						\.push $+3, 1
0103+  0000             #defcont						\ jmp $
0104+  0000             #defcont					\#else
0105+  0000             #defcont						\#if var2_-128>0
0106+  0000             #defcont							\ .org var1_
0107+  0000             #defcont							\.push $+3, 1
0108+  0000             #defcont							\ jmp $
0109+  0000             #defcont						\#else
0110+  0000             #defcont							\.push var1_, 0
0111+  0000             #defcont							\ .byte var2_
0112+  0000             #defcont							\ .org var1_
0113+  0000             #defcont							\ BRA $
0114+  0000             #defcont							\ .org var1_+2
0115+  0000             #defcont						\#endif
0116+  0000             #defcont					\#endif
0117+  0000             #defcont				\#else
0118+  0000             #defcont					\ .byte var1_-var4_-2+2
0119+  0000             #defcont					\ .org var1_
0120+  0000             #defcont					\.push $, 0
0121+  0000             #defcont					\ y $		
0122+  0000             #defcont				\#endif
0123+  0000             #defcont			\#else
0124+  0000             #defcont				\.error "Duplicate ELSE Statement"
0125+  0000             #defcont			\#endif
0126+  0000             #defcont		\#else
0127+  0000             #defcont			\ .error "Misplaced Else"
0128+  0000             #defcont		\#endif
0129+  0000             
0130+  0000             
0131+  0000             ;*******************************************************************
0132+  0000             ;* Defines how to use the various logic macros defined above.      *
0133+  0000             ;*******************************************************************
0134+  0000             #define	ifeq	logic_ifxx(BNE)		
0135+  0000             #define	ifne	logic_ifxx(BEQ)
0136+  0000             #define	ifpl	logic_ifxx(BMI)
0137+  0000             #define	ifhi	logic_ifxx(BLO)
0138+  0000             #define	ifmi	logic_ifxx(BPL)
0139+  0000             #define	iflo	logic_ifxx(BHI)
0140+  0000             #define	ifcs	logic_ifxx(BCC)
0141+  0000             #define	ifcc	logic_ifxx(BCS)
0142+  0000             #define 	ifvc	logic_ifxx(BVS)
0143+  0000             #define 	ifvs	logic_ifxx(BVC)
0144+  0000             #define	ifge	logic_ifxx(BLO)
0145+  0000             #define	ifgt	logic_ifxx(BLS)
0146+  0000             
0147+  0000             #define	else  	logic_else(0,0)
0148+  0000             #define	else_eq	logic_else(1,BEQ)
0149+  0000             #define	else_ne	logic_else(1,BNE)
0150+  0000             #define	else_pl	logic_else(1,BPL)
0151+  0000             #define	else_mi	logic_else(1,BMI)
0152+  0000             #define	else_cc	logic_else(1,BCC)
0153+  0000             #define	else_cs	logic_else(1,BCS)
0154+  0000             
0155+  0000             #define 	endif		logic_end
0156+  0000             
0157+  0000             #define	eqend	logic_loopend(BNE,BEQ)		
0158+  0000             #define	neend	logic_loopend(BEQ,BNE)		
0159+  0000             #define	plend	logic_loopend(BMI,BPL)
0160+  0000             #define	miend	logic_loopend(BPL,BMI)
0161+  0000             #define	csend	logic_loopend(BCC,BCS)
0162+  0000             #define	ccend	logic_loopend(BCS,BCC)
0163+  0000             #define	vcend	logic_loopend(BVS,BVC)
0164+  0000             #define	vsend	logic_loopend(BVC,BVS)
0165+  0000             
0166+  0000             #define	loopend	logic_loopend(BRA,BRA)
0167+  0000             
0168+  0000             #define	lsb(x)	x&$FF
0169+  0000             
0170+  0000             #define	msb(x)	(x>>8)&$FF0002   0000             
0003   0000             displayStrobe: 	.equ $2800
0004   0000             displayBcd: 	.equ $2802
0005   0000             displayStrobeC:	.equ $2801
0006   0000             displayBcdC:	.equ $2803
0007   0000             lampRow:		.equ $2400
0008   0000             lampRowC:		.equ $2401
0009   0000             lampStrobe:		.equ $2402
0010   0000             lampStrobeC:	.equ $2403
0011   0000             switchStrobe:	.equ $3002
0012   0000             switchStrobeC:	.equ $3003
0013   0000             switchRow:		.equ $3000
0014   0000             switchRowC:		.equ $3001
0015   0000             solenoidA:		.equ $2200
0016   0000             solenoidAC		.equ $2201
0017   0000             solenoidB:		.equ $2202
0018   0000             solenoidBC:		.equ $2203
0019   0000             
0020   0000             RAM:			.equ $0000
0021   0000             cRAM:			.equ $0100
0022   0000             temp:			.equ RAM + $00
0023   0000             counter:		.equ RAM + $02
0024   0000             counter2:		.equ RAM + $03
0025   0000             strobe:			.equ RAM + $07
0026   0000             lampRow1:		.equ RAM + $08
0027   0000             lampRow8:		.equ lampRow1 + 7 
0028   0000             displayBcd1:	.equ RAM + $10
0029   0000             displayBcd16:	.equ RAM + $1F
0030   0000             switchRow1:		.equ RAM + $20
0031   0000             switchRow8:		.equ switchRow1 + 7 
0032   0000             solAStatus:		.equ RAM + $28
0033   0000             solBStatus:		.equ RAM + $29
0034   0000             curCol:			.equ RAM + $50
0035   0000             curSwitchRowLsb	.equ RAM + $52
0036   0000             tempX:			.equ RAM + $53 ; 54
0037   0000             queueHead:		.equ RAM + $55 ; 56
0038   0000             queueTail:		.equ RAM + $57 ; 58
0039   0000             
0040   0000             queue:			.equ RAM + $60	; closed | switch? | number#6
0041   0000             queueLast:		.equ RAM + $6F
0042   0000             
0043   0000             settleRow1:		.equ cRAM + $00 ;must be at 0
0044   0000             settleRow8:		.equ settleRow1+  8*8-1
0045   0000             solenoid1:		.equ cRAM + $40
0046   0000             solenoid8:		.equ solenoid1 + 7
0047   0000             solenoid9:		.equ solenoid1 + 8
0048   0000             solenoid16:		.equ solenoid1 + 15
0049   0000             pA_10:			.equ cRAM + $50
0050   0000             pA_1m:			.equ pA_10 + 5
0051   0000             pB_10:			.equ pA_1m + 1
0052   0000             pB_1m:			.equ pB_10 + 5
0053   0000             pC_10:			.equ pB_1m + 1
0054   0000             pC_1m:			.equ pC_10 + 5
0055   0000             pD_10:			.equ pC_1m + 1
0056   0000             pD_1m:			.equ pD_10 + 5  
0057   0000             displayCol:		.equ cRAM + $68
0058   0000             state:			.equ cRAM + $69	; gameover | ? | ? | ?
0059   0000             
0060   0000             instant:		.equ 4
0061   0000             debounce:		.equ 1
0062   0000             slow:			.equ 2
0063   0000             
0064   0000             switchSettle:	.equ cRAM + $30
0065   0000             ; through $7F ?
0066   0000             
0067   6100             none:	.org $6000 + 256
0068   6100 39          	rts
0069   6101             	
0070   6101             	.msfirst
0071   6000             callbackTable: 	.org $6000
0072   6000 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0072   6002 61 00       
0072   6004 61 00       
0072   6006 61 00       
0072   6008 61 00       
0072   600A 61 00       
0072   600C 61 00       
0072   600E 61 00       
0073   6010 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0073   6012 61 00       
0073   6014 61 00       
0073   6016 61 00       
0073   6018 61 00       
0073   601A 61 00       
0073   601C 61 00       
0073   601E 61 00       
0074   6020 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0074   6022 61 00       
0074   6024 61 00       
0074   6026 61 00       
0074   6028 61 00       
0074   602A 61 00       
0074   602C 61 00       
0074   602E 61 00       
0075   6030 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0075   6032 61 00       
0075   6034 61 00       
0075   6036 61 00       
0075   6038 61 00       
0075   603A 61 00       
0075   603C 61 00       
0075   603E 61 00       
0076   6040 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0076   6042 61 00       
0076   6044 61 00       
0076   6046 61 00       
0076   6048 61 00       
0076   604A 61 00       
0076   604C 61 00       
0076   604E 61 00       
0077   6050 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0077   6052 61 00       
0077   6054 61 00       
0077   6056 61 00       
0077   6058 61 00       
0077   605A 61 00       
0077   605C 61 00       
0077   605E 61 00       
0078   6060 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0078   6062 61 00       
0078   6064 61 00       
0078   6066 61 00       
0078   6068 61 00       
0078   606A 61 00       
0078   606C 61 00       
0078   606E 61 00       
0079   6070 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0079   6072 61 00       
0079   6074 61 00       
0079   6076 61 00       
0079   6078 61 00       
0079   607A 61 00       
0079   607C 61 00       
0079   607E 61 00       
0080   6080             ; on = how many cycles it must be on for before registering (1 cycle = 16ms (?)) (max 7)
0081   6080             ; off = how many cycles it must be off for
0082   6080             ; onOnly = if true, don't notify of an off event (also set off = 0 for efficiency)
0083   6080             ; gameover = whether the switch is active in gameover mode (these callbacks must check whether in game over when triggered)
0084   6080             #define SW(on,off,onOnly,gameover) .db (gameover<<7)(onOnly<<6)|(on<<3)|(off) 
0085   6080             settleTable: ; must be right after callbackTable
0086   6080 07          	SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)
0086   6081 07          
0086   6082 07          
0086   6083 07          
0086   6084 07          
0086   6085 07          
0086   6086 07          
0086   6087 07          
0087   6088 07          	SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)
0087   6089 07          
0087   608A 07          
0087   608B 07          
0087   608C 07          
0087   608D 07          
0087   608E 07          
0087   608F 07          
0088   6090 07          	SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)
0088   6091 07          
0088   6092 07          
0088   6093 07          
0088   6094 07          
0088   6095 07          
0088   6096 07          
0088   6097 07          
0089   6098 07          	SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)
0089   6099 07          
0089   609A 07          
0089   609B 07          
0089   609C 07          
0089   609D 07          
0089   609E 07          
0089   609F 07          
0090   60A0 07          	SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)
0090   60A1 07          
0090   60A2 07          
0090   60A3 07          
0090   60A4 07          
0090   60A5 07          
0090   60A6 07          
0090   60A7 07          
0091   60A8 07          	SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)
0091   60A9 07          
0091   60AA 07          
0091   60AB 07          
0091   60AC 07          
0091   60AD 07          
0091   60AE 07          
0091   60AF 07          
0092   60B0 07          	SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)
0092   60B1 07          
0092   60B2 07          
0092   60B3 07          
0092   60B4 07          
0092   60B5 07          
0092   60B6 07          
0092   60B7 07          
0093   60B8 07          	SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)
0093   60B9 07          
0093   60BA 07          
0093   60BB 07          
0093   60BC 07          
0093   60BD 07          
0093   60BE 07          
0093   60BF 07          
0094   60C0             	
0095   7800             main:		.org $7800
0096   7800             	
0097   7800 86 00       	ldaA 	#0
0098   7802 97 00       	staA	temp
0099   7804 86 FF       	ldaA	#$FF
0100   7806 97 01       	staA	temp + 1
0101   7808 9E 00       	ldS		temp
0102   780A             
0103   780A             test:
0104   780A             	
0105   780A             piaSetup:
0106   780A 86 00       	ldaA	#00000000b	;select direction (3rd bit = 0)
0107   780C B7 28 01    	staA 	displayStrobeC
0108   780F 86 3F       	ldaA 	#00111111b	;set LED pins to outputs
0109   7811 B7 28 00    	staA 	displayStrobe
0110   7814 86 04       	ldaA 	#00000100b 	;select data (3rb bit = 1)
0111   7816 B7 28 01    	staA 	displayStrobeC
0112   7819             	
0113   7819 86 00       	ldaA	#00000000b	;select direction (3rd bit = 0)
0114   781B B7 28 03    	staA 	displayBcdC
0115   781E 86 FF       	ldaA 	#11111111b	;set display BCD to output
0116   7820 B7 28 02    	staA 	displayBcd
0117   7823 86 04       	ldaA 	#00000100b 	;select data (3rb bit = 1)
0118   7825 B7 28 03    	staA 	displayBcdC
0119   7828             	
0120   7828 86 00       	ldaA	#00000000b	;select direction (3rd bit = 0)
0121   782A B7 24 01    	staA 	lampRowC
0122   782D 86 FF       	ldaA 	#11111111b	;set to output
0123   782F B7 24 00    	staA 	lampRow
0124   7832 86 04       	ldaA 	#00000100b 	;select data (3rb bit = 1)
0125   7834 B7 24 01    	staA 	lampRowC
0126   7837             	
0127   7837 86 00       	ldaA	#00000000b	;select direction (3rd bit = 0)
0128   7839 B7 24 03    	staA 	lampStrobeC
0129   783C 86 FF       	ldaA 	#11111111b	;set to output
0130   783E B7 24 02    	staA 	lampStrobe
0131   7841 86 04       	ldaA 	#00000100b 	;select data (3rb bit = 1)
0132   7843 B7 24 03    	staA 	lampStrobeC
0133   7846             	
0134   7846 86 00       	ldaA	#00000000b	;select direction (3rd bit = 0)
0135   7848 B7 30 03    	staA 	switchStrobeC
0136   784B 86 FF       	ldaA 	#11111111b	;set to output
0137   784D B7 30 02    	staA 	switchStrobe
0138   7850 86 04       	ldaA 	#00000100b 	;select data (3rb bit = 1)
0139   7852 B7 30 03    	staA 	switchStrobeC
0140   7855             	
0141   7855 86 00       	ldaA	#00000000b	;select direction (3rd bit = 0)
0142   7857 B7 30 01    	staA 	switchRowC
0143   785A 86 00       	ldaA 	#00000000b	;set to input
0144   785C B7 30 00    	staA 	switchRow
0145   785F 86 04       	ldaA 	#00000100b 	;select data (3rb bit = 1)
0146   7861 B7 30 01    	staA 	switchRowC
0147   7864             	
0148   7864 86 00       	ldaA	#00000000b	;select direction (3rd bit = 0)
0149   7866 B7 22 01    	staA 	solenoidAC
0150   7869 B7 22 03    	staA	solenoidBC
0151   786C 86 FF       	ldaA 	#11111111b	;set to output
0152   786E B7 22 00    	staA 	solenoidA
0153   7871 B7 22 02    	staA 	solenoidB
0154   7874 86 04       	ldaA 	#00000100b 	;select data (3rb bit = 1)
0155   7876 B7 22 01    	staA 	solenoidAC
0156   7879 B7 22 03    	staA 	solenoidBC
0157   787C             	
0158   787C             ;
0159   787C             
0160   787C 86 00       	ldaA	#00
0161   787E D7 10       	staB	displayBcd1
0162   7880             	
0163   7880 86 FF       	ldaA	#$FF	
0164   7882 B7 28 00    	staA 	displayStrobe
0165   7885             
0166   7885 86 00       	ldaA	#00
0167   7887 97 07       	staA	strobe
0168   7889 B7 01 68    	staA	displayCol
0169   788C             	
0170   788C CE 00 00    	ldX 	#0
0171   788F DF 50       	stX		curCol
0172   7891             	
0173   7891 86 00       	ldaA	#0
0174   7893 97 52       	staA	curSwitchRowLsb
0175   7895             	
0176   7895             ; fill solenoid status with off
0177   7895 86 00       	ldaA	#0
0178   7897 CE 01 40    	ldX		#solenoid1
0179   789A             lSolDefault:
0180   789A A7 00       	staA	0, X
0181   789C 08          	inX
0182   789D 8C 01 4F    	cpX		#solenoid16
0183   78A0 2F F8       	ble		lSolDefault
0184   78A2             	
0185   78A2             ; empty settle
0186   78A2 86 00       	ldaA	#$00
0187   78A4 CE 01 00    	ldX		#settleRow1
0188   78A7             lSettleDefault:
0189   78A7 A7 00       	staA		0, X
0190   78A9 08          	inX
0191   78AA 8C 08 46    	cpX		#settleRow8 + 7
0192   78AD 2F F8       	ble		lSettleDefault
0193   78AF             	
0194   78AF             ; empty queue
0195   78AF 86 FF       	ldaA	#$FF
0196   78B1 CE 00 60    	ldX		#queue
0197   78B4             lEmptyQueue:
0198   78B4 A7 00       	staA		0, X
0199   78B6 08          	inX
0200   78B7 8C 00 6F    	cpX		#queueLast
0201   78BA 2F F8       	ble		lEmptyQueue
0202   78BC             	
0203   78BC 86 00       	ldaA	#0
0204   78BE 97 55       	staA	queueHead + 0
0205   78C0 97 57       	staA	queueTail + 0
0206   78C2 86 60       	ldaA	#queue
0207   78C4 97 56       	staA	queueHead + 1
0208   78C6 97 58       	staA	queueTail + 1
0209   78C8             	
0210   78C8             ; test numbers
0211   78C8 CE 00 11    	ldX		#displayBcd1 + 1
0212   78CB 86 00       	ldaA	#0
0213   78CD             lTestNumbers:
0214   78CD A7 00       	staA	0, X
0215   78CF 08          	inX
0216   78D0 4C          	incA
0217   78D1 84 07       	andA	#00000111b
0218   78D3 8C 00 1F    	cpX		#displayBcd16
0219   78D6 2F F5       	ble		lTestNumbers
0220   78D8             	
0221   78D8             	
0222   78D8             ; setup complete
0223   78D8 0E          	clI		; enable timer interrupt
0224   78D9             	
0225   78D9             	
0226   78D9             end:
0227   78D9 7E 78 D9    	jmp		end ;disable queue emptying
0228   78DC             	
0229   78DC             	
0230   78DC 86 0F       	ldaA	#00001111b
0231   78DE             	;andA	queueStart
0232   78DE             	
0233   78DE             	
0234   78DE 86 08       				ldaA	#1000b	; gameover
0235   78E0 B5 01 69    				bitA	state
0236   78E3             				ifne	; in gameover
0236   78E3             
0236   78E3 27 FE       
0237   78E5 86 80       					ldaA #10000000b; 
0238   78E7 95 00       					bitA
0239   78E9             				endif
0239   78E9             
0239   78E9             
0239   78E9             
0239   78E9             
0239   78E9             
0239   78E9~            				endif
0239   78E9~            				endif
0239   78E9             
0239   78E9~            				endif
0239   78E9~            				endif
0239   78E9             
0239   78E4             
0239   78E4 04          
0239   78E5             
0239   78E5             
0239   78E5~            				endif
0239   78E5~            				endif
0239   78E5~            				endif
0239   78E5             
0239   78E9             
0239   78E9~            				endif
0239   78E9~            				endif
0239   78E9             
0240   78E9             				
0241   78E9             skipSwitch:
0242   78E9             				
0243   78E9             	
0244   78E9             				
0245   78E9 7E 78 D9    	jmp		end
0246   78EC 00 00       	.dw 0
0247   78EE 00 00       	.dw 0
0248   78F0 00 00       	.dw 0
0249   78F2 00 00       	.dw 0
0250   78F4 00 00       	.dw 0
0251   78F6             		
0252   78F6             interrupt:	
0253   78F6 7C 00 02    	inc		counter
0254   78F9 86 00       	ldaA	#0
0255   78FB 91 02       	cmpA	counter
0256   78FD 26 25       	bne		counterHandled
0257   78FF 7C 00 03    	inc 	counter2
0258   7902 86 04       	ldaA	#4
0259   7904 91 03       	cmpA	counter2
0260   7906 26 1C       	bne		counterHandled
0261   7908             	
0262   7908 86 00       	ldaA	#0
0263   790A 97 03       	staA	counter2
0264   790C 86 77       	ldaA	#01110111b
0265   790E 91 10       	cmpA	displayBcd1
0266   7910 27 0A       	beq		on
0267   7912             	
0268   7912 86 F0       	ldaA	#$F0
0269   7914 97 08       	staA	lampRow1
0270   7916 86 77       	ldaA	#01110111b
0271   7918 97 10       	staA	displayBcd1	
0272   791A 20 08       	bra		counterHandled
0273   791C             on:
0274   791C 86 0F       	ldaA	#$0F
0275   791E 97 08       	staA	lampRow1
0276   7920 86 33       	ldaA	#00110011b
0277   7922 97 10       	staA	displayBcd1	
0278   7924             
0279   7924             counterHandled:
0280   7924             ; move switch column
0281   7924 96 07       	ldaA	strobe
0282   7926 B7 30 02    	staA	switchStrobe
0283   7929             	
0284   7929             ; update display 
0285   7929 DE 50       	ldX		curCol
0286   792B B6 01 68    	ldaA	displayCol
0287   792E C6 FF       	ldaB 	#$FF
0288   7930 F7 28 02    	staB	displayBcd
0289   7933 B7 28 00    	staA	displayStrobe
0290   7936 85 08       	bitA	#00001000b
0291   7938             	ifeq
0291   7938             
0291   7938 26 FE       
0292   793A E6 10       		ldaB	displayBcd1, X
0293   793C             	else
0293   793C             
0293   793C             
0293   793C             
0293   793C             
0293   7939             
0293   7939             
0293   7939             
0293   7939~            	else
0293   7939~            	else
0293   7939~            	else
0293   7939~            	else
0293   7939             
0293   7939~            	else
0293   7939~            	else
0293   7939~            	else
0293   7939~            	else
0293   7939             
0293   7939             
0293   7939 04          
0293   793C             
0293   793C 20 FE       
0293   793E             
0293   793E             
0293   793E             
0293   793E~            	else
0293   793E~            	else
0293   793E~            	else
0293   793E~            	else
0293   793E~            	else
0293   793E             
0293   793E~            	else
0293   793E~            	else
0293   793E             
0293   793E~            	else
0293   793E~            	else
0293   793E             
0294   793E E6 18       		ldaB	displayBcd1 + 8, X
0295   7940             	endif
0295   7940             
0295   7940             
0295   7940             
0295   7940             
0295   7940             
0295   7940~            	endif
0295   7940~            	endif
0295   7940             
0295   7940~            	endif
0295   7940~            	endif
0295   7940             
0295   793D             
0295   793D 02          
0295   793E             
0295   793E             
0295   793E~            	endif
0295   793E~            	endif
0295   793E~            	endif
0295   793E             
0295   7940             
0295   7940~            	endif
0295   7940~            	endif
0295   7940             
0296   7940 F7 28 02    	staB	displayBcd
0297   7943             	
0298   7943             ; read switches
0299   7943 DE 50       	ldX		curCol
0300   7945 B6 30 00    	ldaA	switchRow
0301   7948 16          	tab
0302   7949 A8 20       	eorA	switchRow1, X ; A contains any switches that have changed state
0303   794B             	
0304   794B D6 52       	ldaB	curSwitchRowLsb 	;	B now contains LSB of callbackTable row addr
0305   794D D7 01       	staB	temp + 1 			; temp = switch / 2
0306   794F D7 54       	staB	tempX + 1			; tempX = cRAM
0307   7951 C6 60       	ldaB	#callbackTable >> 8
0308   7953 D7 00       	staB	temp
0309   7955 C6 01       	ldaB	#cRAM >> 8
0310   7957 D7 53       	staB	tempX
0311   7959             	
0312   7959 C6 01       	ldaB	#00000001b ; B is the bit of the current switch in row
0313   795B             	
0314   795B             	; temp now contains the beginning of the row in the callbackTable
0315   795B             swNext:
0316   795B 85 01       	bitA	#00000001b	 ; Z set if switch not different
0317   795D             	ifne		; if bit set, switch different
0317   795D             
0317   795D 27 FE       
0318   795F 36          		pshA ; store changed switches left
0319   7960 DE 53       		ldX		tempX
0320   7962 A6 00       		ldaA	0, X ; A now how long the switch has left to settle
0321   7964 84 0F       		andA	#00001111b ; need to remove upper F ( sets Z if A = 0)
0322   7966             		ifne 	; A>0 -> settling
0322   7966             
0322   7966 27 FE       
0323   7968 4A          			decA
0324   7969 A7 00       			staA	0, X	; sets Z if now A = 0
0325   796B             			ifeq ; A=0 -> now settled, fire event
0325   796B             
0325   796B 26 FE       
0326   796D             settled:		
0327   796D DE 50       				ldX		curCol
0328   796F 17          				tBA	; A now the bit in row
0329   7970 A8 20       				eorA	switchRow1, X ; toggle bit in row
0330   7972 A7 20       				staA	switchRow1, X ; A now state of row
0331   7974             				
0332   7974 F5 30 00    				bitB	switchRow
0333   7977             				ifne ; switch now on
0333   7977             
0333   7977 27 FE       
0334   7979 86 C0       					ldaA	#11000000b
0335   797B             				else
0335   797B             
0335   797B             
0335   797B             
0335   797B             
0335   7978             
0335   7978             
0335   7978             
0335   7978~            				else
0335   7978~            				else
0335   7978~            				else
0335   7978~            				else
0335   7978             
0335   7978~            				else
0335   7978~            				else
0335   7978~            				else
0335   7978~            				else
0335   7978             
0335   7978             
0335   7978 04          
0335   797B             
0335   797B 20 FE       
0335   797D             
0335   797D             
0335   797D             
0335   797D~            				else
0335   797D~            				else
0335   797D~            				else
0335   797D~            				else
0335   797D~            				else
0335   797D             
0335   797D~            				else
0335   797D~            				else
0335   797D             
0335   797D~            				else
0335   797D~            				else
0335   797D             
0336   797D 86 40       					ldaA	#01000000b
0337   797F             				endif
0337   797F             
0337   797F             
0337   797F             
0337   797F             
0337   797F             
0337   797F~            				endif
0337   797F~            				endif
0337   797F             
0337   797F~            				endif
0337   797F~            				endif
0337   797F             
0337   797C             
0337   797C 02          
0337   797D             
0337   797D             
0337   797D~            				endif
0337   797D~            				endif
0337   797D~            				endif
0337   797D             
0337   797F             
0337   797F~            				endif
0337   797F~            				endif
0337   797F             
0338   797F 9A 54       				oraA	tempX + 1 ; A now contains the event per queue schema
0339   7981             				
0340   7981 DE 57       				ldX		queueTail
0341   7983 A7 00       				staA	0, X
0342   7985             				
0343   7985 7C 00 58    				inc		queueTail + 1
0344   7988             				
0345   7988             				; todo somehow actually fire it here
0346   7988             				;asl		temp + 1
0347   7988             				;ldX		temp	
0348   7988             				;ldX		0, X
0349   7988             				;jsr		0, X
0350   7988             			endif
0350   7988             
0350   7988             
0350   7988             
0350   7988             
0350   7988             
0350   7988~            			endif
0350   7988~            			endif
0350   7988             
0350   7988~            			endif
0350   7988~            			endif
0350   7988             
0350   796C             
0350   796C 1B          
0350   796D             
0350   796D             
0350   796D~            			endif
0350   796D~            			endif
0350   796D~            			endif
0350   796D             
0350   7988             
0350   7988~            			endif
0350   7988~            			endif
0350   7988             
0351   7988             		else ; =0 -> was settled, so now it's not
0351   7988             
0351   7988             
0351   7988             
0351   7988             
0351   7967             
0351   7967             
0351   7967             
0351   7967~            		else ; =0 -> was settled, so now it's not
0351   7967~            		else ; =0 -> was settled, so now it's not
0351   7967~            		else ; =0 -> was settled, so now it's not
0351   7967~            		else ; =0 -> was settled, so now it's not
0351   7967             
0351   7967~            		else ; =0 -> was settled, so now it's not
0351   7967~            		else ; =0 -> was settled, so now it's not
0351   7967~            		else ; =0 -> was settled, so now it's not
0351   7967~            		else ; =0 -> was settled, so now it's not
0351   7967             
0351   7967             
0351   7967 22          
0351   7988             
0351   7988 20 FE       
0351   798A             
0351   798A             
0351   798A             
0351   798A~            		else ; =0 -> was settled, so now it's not
0351   798A~            		else ; =0 -> was settled, so now it's not
0351   798A~            		else ; =0 -> was settled, so now it's not
0351   798A~            		else ; =0 -> was settled, so now it's not
0351   798A~            		else ; =0 -> was settled, so now it's not
0351   798A             
0351   798A~            		else ; =0 -> was settled, so now it's not
0351   798A~            		else ; =0 -> was settled, so now it's not
0351   798A             
0351   798A~            		else ; =0 -> was settled, so now it's not
0351   798A~            		else ; =0 -> was settled, so now it's not
0351   798A             
0352   798A             			; get the settle time
0353   798A 96 54       			ldaA	tempX + 1
0354   798C 97 01       			staA	temp + 1 	; get temp in sync with tempX LSB
0355   798E DE 00       			ldX		temp
0356   7990             			
0357   7990             			; temp contains half the address of the callback, so add diff between settleTable and callbackTable
0358   7990 A6 80       			ldaA	settleTable - callbackTable, X ; A has settle settings
0359   7992             			
0360   7992             			; need to get correct 3 bits from switch settings
0361   7992 F5 30 00    			bitB	switchRow
0362   7995             			ifne ; switch just turned on
0362   7995             
0362   7995 27 FE       
0363   7997 44          				lsrA
0364   7998 44          				lsrA
0365   7999             			else
0365   7999             
0365   7999             
0365   7999             
0365   7999             
0365   7996             
0365   7996             
0365   7996             
0365   7996~            			else
0365   7996~            			else
0365   7996~            			else
0365   7996~            			else
0365   7996             
0365   7996~            			else
0365   7996~            			else
0365   7996~            			else
0365   7996~            			else
0365   7996             
0365   7996             
0365   7996 04          
0365   7999             
0365   7999 20 FE       
0365   799B             
0365   799B             
0365   799B             
0365   799B~            			else
0365   799B~            			else
0365   799B~            			else
0365   799B~            			else
0365   799B~            			else
0365   799B             
0365   799B~            			else
0365   799B~            			else
0365   799B             
0365   799B~            			else
0365   799B~            			else
0365   799B             
0366   799B 48          				aslA
0367   799C             			endif
0367   799C             
0367   799C             
0367   799C             
0367   799C             
0367   799C             
0367   799C~            			endif
0367   799C~            			endif
0367   799C             
0367   799C~            			endif
0367   799C~            			endif
0367   799C             
0367   799A             
0367   799A 01          
0367   799B             
0367   799B             
0367   799B~            			endif
0367   799B~            			endif
0367   799B~            			endif
0367   799B             
0367   799C             
0367   799C~            			endif
0367   799C~            			endif
0367   799C             
0368   799C 84 0E       			andA	#1110b ; A now has 3 bit settle time * 2
0369   799E             						
0370   799E DE 53       			ldX		tempX
0371   79A0 A7 00       			staA	0, X		; start settling	
0372   79A2 27 C9       			beq		settled		; quick out for 0 settle
0373   79A4             		endif
0373   79A4             
0373   79A4             
0373   79A4             
0373   79A4             
0373   79A4             
0373   79A4~            		endif
0373   79A4~            		endif
0373   79A4             
0373   79A4~            		endif
0373   79A4~            		endif
0373   79A4             
0373   7989             
0373   7989 1A          
0373   798A             
0373   798A             
0373   798A~            		endif
0373   798A~            		endif
0373   798A~            		endif
0373   798A             
0373   79A4             
0373   79A4~            		endif
0373   79A4~            		endif
0373   79A4             
0374   79A4             			
0375   79A4 32          		pulA
0376   79A5             	endif
0376   79A5             
0376   79A5             
0376   79A5             
0376   79A5             
0376   79A5             
0376   79A5~            	endif
0376   79A5~            	endif
0376   79A5             
0376   79A5~            	endif
0376   79A5~            	endif
0376   79A5             
0376   795E             
0376   795E 46          
0376   795F             
0376   795F             
0376   795F~            	endif
0376   795F~            	endif
0376   795F~            	endif
0376   795F             
0376   79A5             
0376   79A5~            	endif
0376   79A5~            	endif
0376   79A5             
0377   79A5 7C 00 54    	inc tempX + 1
0378   79A8 58          	aslB
0379   79A9 44          	lsrA			; pop lowest bit off, set Z if A is empty
0380   79AA 26 AF       	bne		swNext 	; more 'switched' bits, keep processing 
0381   79AC             	
0382   79AC             	
0383   79AC             ; update lamps
0384   79AC DE 50       	ldX		curCol
0385   79AE 86 FF       	ldaA	#$FF	;lamp row is inverted
0386   79B0 B7 24 00    	staA	lampRow
0387   79B3 96 07       	ldaA	strobe
0388   79B5 B7 24 02    	staA	lampStrobe
0389   79B8 A6 20       	ldaA	switchRow1, X
0390   79BA B7 24 00    	staA	lampRow
0391   79BD 86 00       	ldaA	#00
0392   79BF             
0393   79BF             ; update solenoids
0394   79BF             	; if a solenoid is set to <254, --
0395   79BF             	; if =255, off, otherwise on
0396   79BF             	; leave it at 254
0397   79BF             	
0398   79BF 7C 00 50    	inc		curCol	; indexed can't use base >255, so temp inc X by 255 (1 MSB)
0399   79C2 86 FE       	ldaA	#254
0400   79C4 DE 50       	ldX		curCol
0401   79C6 E6 40       	ldaB	solenoid1 - cRAM, X
0402   79C8 A1 40       	cmpA	solenoid1 - cRAM, X
0403   79CA             	ifge 	; solenoid <=254, turn on
0403   79CA             
0403   79CA 25 FE       
0404   79CC             		ifgt	; solenoid < 254, decrement
0404   79CC             
0404   79CC 23 FE       
0405   79CE 6A 40       			dec		solenoid1 - cRAM, X
0406   79D0             		endif
0406   79D0             
0406   79D0             
0406   79D0             
0406   79D0             
0406   79D0             
0406   79D0~            		endif
0406   79D0~            		endif
0406   79D0             
0406   79D0~            		endif
0406   79D0~            		endif
0406   79D0             
0406   79CD             
0406   79CD 02          
0406   79CE             
0406   79CE             
0406   79CE~            		endif
0406   79CE~            		endif
0406   79CE~            		endif
0406   79CE             
0406   79D0             
0406   79D0~            		endif
0406   79D0~            		endif
0406   79D0             
0407   79D0 0D          		sec
0408   79D1             	else
0408   79D1             
0408   79D1             
0408   79D1             
0408   79D1             
0408   79CB             
0408   79CB             
0408   79CB             
0408   79CB~            	else
0408   79CB~            	else
0408   79CB~            	else
0408   79CB~            	else
0408   79CB             
0408   79CB~            	else
0408   79CB~            	else
0408   79CB~            	else
0408   79CB~            	else
0408   79CB             
0408   79CB             
0408   79CB 07          
0408   79D1             
0408   79D1 20 FE       
0408   79D3             
0408   79D3             
0408   79D3             
0408   79D3~            	else
0408   79D3~            	else
0408   79D3~            	else
0408   79D3~            	else
0408   79D3~            	else
0408   79D3             
0408   79D3~            	else
0408   79D3~            	else
0408   79D3             
0408   79D3~            	else
0408   79D3~            	else
0408   79D3             
0409   79D3 0C          		clc
0410   79D4             	endif
0410   79D4             
0410   79D4             
0410   79D4             
0410   79D4             
0410   79D4             
0410   79D4~            	endif
0410   79D4~            	endif
0410   79D4             
0410   79D4~            	endif
0410   79D4~            	endif
0410   79D4             
0410   79D2             
0410   79D2 01          
0410   79D3             
0410   79D3             
0410   79D3~            	endif
0410   79D3~            	endif
0410   79D3~            	endif
0410   79D3             
0410   79D4             
0410   79D4~            	endif
0410   79D4~            	endif
0410   79D4             
0411   79D4 76 00 28    	ror		solAStatus
0412   79D7 A1 48       	cmpA	solenoid9 - cRAM, X
0413   79D9             	ifge 	; solenoid <=254, turn on
0413   79D9             
0413   79D9 25 FE       
0414   79DB             		ifgt	; solenoid < 254, decrement
0414   79DB             
0414   79DB 23 FE       
0415   79DD 6A 48       			dec		solenoid9 - cRAM, X
0416   79DF             		endif
0416   79DF             
0416   79DF             
0416   79DF             
0416   79DF             
0416   79DF             
0416   79DF~            		endif
0416   79DF~            		endif
0416   79DF             
0416   79DF~            		endif
0416   79DF~            		endif
0416   79DF             
0416   79DC             
0416   79DC 02          
0416   79DD             
0416   79DD             
0416   79DD~            		endif
0416   79DD~            		endif
0416   79DD~            		endif
0416   79DD             
0416   79DF             
0416   79DF~            		endif
0416   79DF~            		endif
0416   79DF             
0417   79DF 0D          		sec
0418   79E0             	else
0418   79E0             
0418   79E0             
0418   79E0             
0418   79E0             
0418   79DA             
0418   79DA             
0418   79DA             
0418   79DA~            	else
0418   79DA~            	else
0418   79DA~            	else
0418   79DA~            	else
0418   79DA             
0418   79DA~            	else
0418   79DA~            	else
0418   79DA~            	else
0418   79DA~            	else
0418   79DA             
0418   79DA             
0418   79DA 07          
0418   79E0             
0418   79E0 20 FE       
0418   79E2             
0418   79E2             
0418   79E2             
0418   79E2~            	else
0418   79E2~            	else
0418   79E2~            	else
0418   79E2~            	else
0418   79E2~            	else
0418   79E2             
0418   79E2~            	else
0418   79E2~            	else
0418   79E2             
0418   79E2~            	else
0418   79E2~            	else
0418   79E2             
0419   79E2 0C          		clc
0420   79E3             	endif
0420   79E3             
0420   79E3             
0420   79E3             
0420   79E3             
0420   79E3             
0420   79E3~            	endif
0420   79E3~            	endif
0420   79E3             
0420   79E3~            	endif
0420   79E3~            	endif
0420   79E3             
0420   79E1             
0420   79E1 01          
0420   79E2             
0420   79E2             
0420   79E2~            	endif
0420   79E2~            	endif
0420   79E2~            	endif
0420   79E2             
0420   79E3             
0420   79E3~            	endif
0420   79E3~            	endif
0420   79E3             
0421   79E3 76 00 29    	ror		solBStatus
0422   79E6 7A 00 50    	dec		curCol
0423   79E9             	
0424   79E9             ; update strobe	
0425   79E9 DE 50       	ldX		curCol
0426   79EB 08          	inX 	
0427   79EC 86 08       	ldaA	#8 	; pitch
0428   79EE 9B 52       	addA	curSwitchRowLsb
0429   79F0 97 52       	staA	curSwitchRowLsb
0430   79F2 78 00 07    	asl		strobe
0431   79F5 7C 01 68    	inc		displayCol
0432   79F8 86 00       	ldaA	#0
0433   79FA 91 07       	cmpA	strobe ; strobe done?  reset
0434   79FC             	ifeq		
0434   79FC             
0434   79FC 26 FE       
0435   79FE 96 28       		ldaA	solAStatus
0436   7A00 B7 22 00    		staA	solenoidA
0437   7A03 96 29       		ldaA	solBStatus
0438   7A05 B7 22 02    		staA	solenoidB
0439   7A08             	
0440   7A08 86 01       		ldaA	#00000001b
0441   7A0A 97 07       		staA	strobe
0442   7A0C             		
0443   7A0C CE 00 00    		ldX 	#0
0444   7A0F             		
0445   7A0F 86 00       		ldaA	#0
0446   7A11 97 52       		staA	curSwitchRowLsb
0447   7A13 97 28       		staA	solAStatus
0448   7A15 97 29       		staA	solBStatus
0449   7A17             		
0450   7A17 F6 01 68    		ldaB	displayCol	; reset display col only if it's > 7 
0451   7A1A C1 F8       		cmpB	#$F8	; since it needs to count to 15 instead of 7
0452   7A1C             		ifgt
0452   7A1C             
0452   7A1C 23 FE       
0453   7A1E B7 01 68    			staA	displayCol
0454   7A21             		endif
0454   7A21             
0454   7A21             
0454   7A21             
0454   7A21             
0454   7A21             
0454   7A21~            		endif
0454   7A21~            		endif
0454   7A21             
0454   7A21~            		endif
0454   7A21~            		endif
0454   7A21             
0454   7A1D             
0454   7A1D 03          
0454   7A1E             
0454   7A1E             
0454   7A1E~            		endif
0454   7A1E~            		endif
0454   7A1E~            		endif
0454   7A1E             
0454   7A21             
0454   7A21~            		endif
0454   7A21~            		endif
0454   7A21             
0455   7A21             	endif
0455   7A21             
0455   7A21             
0455   7A21             
0455   7A21             
0455   7A21             
0455   7A21~            	endif
0455   7A21~            	endif
0455   7A21             
0455   7A21~            	endif
0455   7A21~            	endif
0455   7A21             
0455   79FD             
0455   79FD 23          
0455   79FE             
0455   79FE             
0455   79FE~            	endif
0455   79FE~            	endif
0455   79FE~            	endif
0455   79FE             
0455   7A21             
0455   7A21~            	endif
0455   7A21~            	endif
0455   7A21             
0456   7A21             	
0457   7A21 DF 50       	stX		curCol
0458   7A23 3B          	rti
0459   7A24             
0460   7FF8             pointers: 	.org $7FF8  	
0461   7FF8             	.msfirst
0462   7FF8 78 F6       	.dw interrupt			
0463   7FFA 78 F6       	.dw interrupt			
0464   7FFC 78 F6       	.dw interrupt			
0465   7FFE 78 00       	.dw main
0466   8000             	
0467   8000             	
0468   8000             	.endtasm: Number of errors = 0
