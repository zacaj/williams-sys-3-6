0001   0000             #include "680xlogic.asm"
0001+  0000             ;***********************************************
0002+  0000             ;* 680X Style Logical Instruction Macros       *
0003+  0000             ;* For use with TASMx Assembler                *
0004+  0000             ;* Written by Jess M. Askey 2001 jess@askey.org*
0005+  0000             ;***********************************************
0006+  0000             .module logic
0007+  0000             
0008+  0000             var1_		.equ	$00
0009+  0000             var2_		.equ	$00
0010+  0000             var3_		.equ	$00
0011+  0000             var4_		.equ	$00
0012+  0000             
0013+  0000             #define     FLAG_IF    	0
0014+  0000             #define     FLAG_ELSE 	1
0015+  0000             #define	FLAG_BEGIN 	2
0016+  0000             
0017+  0000             ;*******************************************************************
0018+  0000             ;* Locate: Pushes two Words                                        *
0019+  0000             ;*                                                                 *
0020+  0000             ;*            Word 1 - address of branch location                  *
0021+  0000             ;*            Word 2 - Type of Operation                           *
0022+  0000             ;*                     0 - Standard ENDIF                          *
0023+  0000             ;*                     1 - ELSE or Logical ELSE                    *
0024+  0000             ;*                     2 - Loop                                    *
0025+  0000             ;*******************************************************************
0026+  0000             #define	logic_loc(type)	     \ .push  *, type
0027+  0000             
0028+  0000             ;*******************************************************************
0029+  0000             ;* Ifxx: These are the standard 'if' statements, they will always  *
0030+  0000             ;*       be of type 0.                                             *
0031+  0000             ;*******************************************************************
0032+  0000             #define	logic_ifxx(x)	     logic_loc(FLAG_IF) \ x  * 
0033+  0000             
0034+  0000             ;*******************************************************************
0035+  0000             ;* Begin: The start marker for logical loops, must terminate with  *
0036+  0000             ;*        an 'xxend' statement.                                    *
0037+  0000             ;******************************************************************* 
0038+  0000             #define     begin(x)		     logic_loc(FLAG_BEGIN)
0039+  0000             
0040+  0000             ;*******************************************************************
0041+  0000             ;* Logic End: This is the end macro for the 'begin' statement. It  *
0042+  0000             ;*            pulls the pc location of the beginning of the loop   *
0043+  0000             ;*            and verifies that the 'type' is correct.             *
0044+  0000             ;*******************************************************************
0045+  0000             #define logic_loopend(x,y)	\ .pop var1_, var2_
0046+  0000             #defcont				\#if (var1_ & FLAG_BEGIN)
0047+  0000             #defcont					\#if ((var2_-*-2+127) <= 0)
0048+  0000             #defcont						\ y	*+5
0049+  0000             #defcont						\ jmp	var2_
0050+  0000             #defcont					\#else
0051+  0000             #defcont						\ x	var2_
0052+  0000             #defcont					\#endif
0053+  0000             #defcont				\#else
0054+  0000             #defcont					\ .error "Inappropriate End for BEGIN Loop."
0055+  0000             #defcont				\#endif
0056+  0000             
0057+  0000             ;*******************************************************************
0058+  0000             ;* Logic Find: Used for ENDIF statement. Will find the pc for the  *
0059+  0000             ;*             previous IF (or ELSE) and update the branch or jump *
0060+  0000             ;*             at that address to point to the current address.    *
0061+  0000             ;*******************************************************************
0062+  0000             #define logic_end \var1_ .set *
0063+  0000             #defcont		\ .pop var3_, var4_
0064+  0000             #defcont		\#if (var3_ & FLAG_BEGIN)==0 
0065+  0000             #defcont			\#if (var3_ & FLAG_ELSE)==0	
0066+  0000             #defcont  				\var2_ .set var1_-var4_-2
0067+  0000             #defcont				\#if var2_+127 < 0
0068+  0000             #defcont					\ .error "Branch Range < -127"
0069+  0000             #defcont				\#else
0070+  0000             #defcont					\#if var2_-128 > 0
0071+  0000             #defcont						\ .error "Branch Range > 128"
0072+  0000             #defcont					\#else
0073+  0000             #defcont    					\ .org var4_+1
0074+  0000             #defcont						\ .byte var2_
0075+  0000             #defcont					\#endif
0076+  0000             #defcont				\#endif
0077+  0000             #defcont			\#else	
0078+  0000             #defcont    			\ .org  var4_-2	
0079+  0000             #defcont				\ .word var1_
0080+  0000             #defcont			\#endif
0081+  0000             #defcont			\ .org	var1_
0082+  0000             #defcont		\#else
0083+  0000             #defcont			\.error "Wrong Endtype for IF block"
0084+  0000             #defcont		\#endif
0085+  0000             
0086+  0000             ;*******************************************************************
0087+  0000             ;* Logic Else: Can act as a standard else or a complex else        *
0088+  0000             ;*             (ie. with additional logic as defined below). The   *
0089+  0000             ;*             ELSE block will resove how to terminate the current *
0090+  0000             ;*             code and then set the owning IF statement's data    *
0091+  0000             ;*             byte.                                               *
0092+  0000             ;*******************************************************************
0093+  0000             #define	logic_else(x,y)	\var1_ .set $
0094+  0000             #defcont		\ .pop var3_, var4_
0095+  0000             #defcont		\#if (var3_ & FLAG_BEGIN)==0
0096+  0000             #defcont			\#if (var3_ & FLAG_ELSE)==0
0097+  0000             #defcont				\ .org var4_+1
0098+  0000             #defcont	      		\#if x==0
0099+  0000             #defcont					\var2_ .set var1_-var4_-2+2
0100+  0000             #defcont					\#if var2_+127 < 0
0101+  0000             #defcont						\ .org var1_
0102+  0000             #defcont						\.push $+3, 1
0103+  0000             #defcont						\ jmp $
0104+  0000             #defcont					\#else
0105+  0000             #defcont						\#if var2_-128>0
0106+  0000             #defcont							\ .org var1_
0107+  0000             #defcont							\.push $+3, 1
0108+  0000             #defcont							\ jmp $
0109+  0000             #defcont						\#else
0110+  0000             #defcont							\.push var1_, 0
0111+  0000             #defcont							\ .byte var2_
0112+  0000             #defcont							\ .org var1_
0113+  0000             #defcont							\ BRA $
0114+  0000             #defcont							\ .org var1_+2
0115+  0000             #defcont						\#endif
0116+  0000             #defcont					\#endif
0117+  0000             #defcont				\#else
0118+  0000             #defcont					\ .byte var1_-var4_-2+2
0119+  0000             #defcont					\ .org var1_
0120+  0000             #defcont					\.push $, 0
0121+  0000             #defcont					\ y $		
0122+  0000             #defcont				\#endif
0123+  0000             #defcont			\#else
0124+  0000             #defcont				\.error "Duplicate ELSE Statement"
0125+  0000             #defcont			\#endif
0126+  0000             #defcont		\#else
0127+  0000             #defcont			\ .error "Misplaced Else"
0128+  0000             #defcont		\#endif
0129+  0000             
0130+  0000             
0131+  0000             ;*******************************************************************
0132+  0000             ;* Defines how to use the various logic macros defined above.      *
0133+  0000             ;*******************************************************************
0134+  0000             #define	ifeq	logic_ifxx(BNE)		
0135+  0000             #define	ifne	logic_ifxx(BEQ)
0136+  0000             #define	ifpl	logic_ifxx(BMI)
0137+  0000             #define	ifhi	logic_ifxx(BLO)
0138+  0000             #define	ifmi	logic_ifxx(BPL)
0139+  0000             #define	iflo	logic_ifxx(BHI)
0140+  0000             #define	ifcs	logic_ifxx(BCC)
0141+  0000             #define	ifcc	logic_ifxx(BCS)
0142+  0000             #define 	ifvc	logic_ifxx(BVS)
0143+  0000             #define 	ifvs	logic_ifxx(BVC)
0144+  0000             #define	ifge	logic_ifxx(BLO)
0145+  0000             #define	ifgt	logic_ifxx(BLS)
0146+  0000             
0147+  0000             #define	else  	logic_else(0,0)
0148+  0000             #define	else_eq	logic_else(1,BEQ)
0149+  0000             #define	else_ne	logic_else(1,BNE)
0150+  0000             #define	else_pl	logic_else(1,BPL)
0151+  0000             #define	else_mi	logic_else(1,BMI)
0152+  0000             #define	else_cc	logic_else(1,BCC)
0153+  0000             #define	else_cs	logic_else(1,BCS)
0154+  0000             
0155+  0000             #define 	endif		logic_end
0156+  0000             
0157+  0000             #define	eqend	logic_loopend(BNE,BEQ)		
0158+  0000             #define	neend	logic_loopend(BEQ,BNE)		
0159+  0000             #define	plend	logic_loopend(BMI,BPL)
0160+  0000             #define	miend	logic_loopend(BPL,BMI)
0161+  0000             #define	csend	logic_loopend(BCC,BCS)
0162+  0000             #define	ccend	logic_loopend(BCS,BCC)
0163+  0000             #define	vcend	logic_loopend(BVS,BVC)
0164+  0000             #define	vsend	logic_loopend(BVC,BVS)
0165+  0000             
0166+  0000             #define	loopend	logic_loopend(BRA,BRA)
0167+  0000             
0168+  0000             #define	lsb(x)	x&$FF
0169+  0000             
0170+  0000             #define	msb(x)	(x>>8)&$FF0002   0000             
0003   0000             displayStrobe: 	.equ $2800
0004   0000             displayBcd: 	.equ $2802
0005   0000             displayStrobeC:	.equ $2801
0006   0000             displayBcdC:	.equ $2803
0007   0000             lampRow:		.equ $2400
0008   0000             lampRowC:		.equ $2401
0009   0000             lampStrobe:		.equ $2402
0010   0000             lampStrobeC:	.equ $2403
0011   0000             switchStrobe:	.equ $3002
0012   0000             switchStrobeC:	.equ $3003
0013   0000             switchRow:		.equ $3000
0014   0000             switchRowC:		.equ $3001
0015   0000             solenoidA:		.equ $2200
0016   0000             solenoidAC		.equ $2201
0017   0000             solenoidB:		.equ $2202
0018   0000             solenoidBC:		.equ $2203
0019   0000             
0020   0000             RAM:			.equ $0000
0021   0000             cRAM:			.equ $0100
0022   0000             temp:			.equ RAM + $00
0023   0000             counter:		.equ RAM + $02
0024   0000             counter2:		.equ RAM + $03
0025   0000             strobe:			.equ RAM + $07
0026   0000             lampRow1:		.equ RAM + $08
0027   0000             lampRow8:		.equ lampRow1 + 7 
0028   0000             displayBcd1:	.equ RAM + $10
0029   0000             
0030   0000             switchRow1:		.equ RAM + $20
0031   0000             switchRow8:		.equ switchRow1 + 7 
0032   0000             solAStatus:		.equ RAM + $28
0033   0000             solBStatus:		.equ RAM + $29
0034   0000             curCol:			.equ RAM + $50
0035   0000             curSwitchRowLsb	.equ RAM + $52
0036   0000             tempX:			.equ RAM + $53
0037   0000             
0038   0000             settleRow1:		.equ cRAM + $00
0039   0000             settleRow8:		.equ settleRow1+  8*8-1
0040   0000             solenoid1:		.equ cRAM + $40
0041   0000             solenoid8:		.equ solenoid1 + 7
0042   0000             solenoid9:		.equ solenoid1 + 8
0043   0000             solenoid16:		.equ solenoid1 + 15
0044   0000             pA_10:			.equ cRAM + $50
0045   0000             pA_1m:			.equ pA_10 + 5
0046   0000             pB_10:			.equ pA_1m + 1
0047   0000             pB_1m:			.equ pB_10 + 5
0048   0000             pC_10:			.equ pB_1m + 1
0049   0000             pC_1m:			.equ pC_10 + 5
0050   0000             pD_10:			.equ pC_1m + 1
0051   0000             pD_1m:			.equ pD_10 + 5  
0052   0000             
0053   0000             instant:		.equ 4
0054   0000             debounce:		.equ 1
0055   0000             slow:			.equ 2
0056   0000             
0057   0000             switchSettle:	.equ cRAM + $30
0058   0000             ; through $7F ?
0059   0000             
0060   6100             none:	.org $6000 + 256
0061   6100 39          	rts
0062   6101             	
0063   6101             	.msfirst
0064   6101             #define SW(y,x) .db x \ .dw y 
0065   6101             
0066   6000             switchTable: 	.org $6000
0067   6000 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0067   6002 61 00       
0067   6004 61 00       
0067   6006 61 00       
0067   6008 61 00       
0067   600A 61 00       
0067   600C 61 00       
0067   600E 61 00       
0068   6010 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0068   6012 61 00       
0068   6014 61 00       
0068   6016 61 00       
0068   6018 61 00       
0068   601A 61 00       
0068   601C 61 00       
0068   601E 61 00       
0069   6020 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0069   6022 61 00       
0069   6024 61 00       
0069   6026 61 00       
0069   6028 61 00       
0069   602A 61 00       
0069   602C 61 00       
0069   602E 61 00       
0070   6030 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0070   6032 61 00       
0070   6034 61 00       
0070   6036 61 00       
0070   6038 61 00       
0070   603A 61 00       
0070   603C 61 00       
0070   603E 61 00       
0071   6040 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0071   6042 61 00       
0071   6044 61 00       
0071   6046 61 00       
0071   6048 61 00       
0071   604A 61 00       
0071   604C 61 00       
0071   604E 61 00       
0072   6050 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0072   6052 61 00       
0072   6054 61 00       
0072   6056 61 00       
0072   6058 61 00       
0072   605A 61 00       
0072   605C 61 00       
0072   605E 61 00       
0073   6060 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0073   6062 61 00       
0073   6064 61 00       
0073   6066 61 00       
0073   6068 61 00       
0073   606A 61 00       
0073   606C 61 00       
0073   606E 61 00       
0074   6070 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0074   6072 61 00       
0074   6074 61 00       
0074   6076 61 00       
0074   6078 61 00       
0074   607A 61 00       
0074   607C 61 00       
0074   607E 61 00       
0075   6080             settleTable:
0076   6080 0D          	.db 13\.db 13\.db 13\.db 13\.db 13\.db 13\.db 13\.db 13
0076   6081 0D          
0076   6082 0D          
0076   6083 0D          
0076   6084 0D          
0076   6085 0D          
0076   6086 0D          
0076   6087 0D          
0077   6088 0D          	.db 13\.db 13\.db 13\.db 13\.db 13\.db 13\.db 13\.db 13
0077   6089 0D          
0077   608A 0D          
0077   608B 0D          
0077   608C 0D          
0077   608D 0D          
0077   608E 0D          
0077   608F 0D          
0078   6090 0D          	.db 13\.db 13\.db 13\.db 13\.db 13\.db 13\.db 13\.db 13
0078   6091 0D          
0078   6092 0D          
0078   6093 0D          
0078   6094 0D          
0078   6095 0D          
0078   6096 0D          
0078   6097 0D          
0079   6098 0D          	.db 13\.db 13\.db 13\.db 13\.db 13\.db 13\.db 13\.db 13
0079   6099 0D          
0079   609A 0D          
0079   609B 0D          
0079   609C 0D          
0079   609D 0D          
0079   609E 0D          
0079   609F 0D          
0080   60A0 0D          	.db 13\.db 13\.db 13\.db 13\.db 13\.db 13\.db 13\.db 13
0080   60A1 0D          
0080   60A2 0D          
0080   60A3 0D          
0080   60A4 0D          
0080   60A5 0D          
0080   60A6 0D          
0080   60A7 0D          
0081   60A8 0D          	.db 13\.db 13\.db 13\.db 13\.db 13\.db 13\.db 13\.db 13
0081   60A9 0D          
0081   60AA 0D          
0081   60AB 0D          
0081   60AC 0D          
0081   60AD 0D          
0081   60AE 0D          
0081   60AF 0D          
0082   60B0 0D          	.db 13\.db 13\.db 13\.db 13\.db 13\.db 13\.db 13\.db 13
0082   60B1 0D          
0082   60B2 0D          
0082   60B3 0D          
0082   60B4 0D          
0082   60B5 0D          
0082   60B6 0D          
0082   60B7 0D          
0083   60B8 0D          	.db 13\.db 13\.db 13\.db 13\.db 13\.db 13\.db 13\.db 0
0083   60B9 0D          
0083   60BA 0D          
0083   60BB 0D          
0083   60BC 0D          
0083   60BD 0D          
0083   60BE 0D          
0083   60BF 00          
0084   60C0             	
0085   7800             main:		.org $7800
0086   7800             	
0087   7800 86 00       	ldaA 	#0
0088   7802 97 00       	staA	temp
0089   7804 86 FF       	ldaA	#$FF
0090   7806 97 01       	staA	temp + 1
0091   7808 9E 00       	ldS		temp
0092   780A             
0093   780A             test:
0094   780A             	
0095   780A             piaSetup:
0096   780A 86 00       	ldaA	#00000000b	;select direction (3rd bit = 0)
0097   780C B7 28 01    	staA 	displayStrobeC
0098   780F 86 3F       	ldaA 	#00111111b	;set LED pins to outputs
0099   7811 B7 28 00    	staA 	displayStrobe
0100   7814 86 04       	ldaA 	#00000100b 	;select data (3rb bit = 1)
0101   7816 B7 28 01    	staA 	displayStrobeC
0102   7819             	
0103   7819 86 00       	ldaA	#00000000b	;select direction (3rd bit = 0)
0104   781B B7 28 03    	staA 	displayBcdC
0105   781E 86 FF       	ldaA 	#11111111b	;set display BCD to output
0106   7820 B7 28 02    	staA 	displayBcd
0107   7823 86 04       	ldaA 	#00000100b 	;select data (3rb bit = 1)
0108   7825 B7 28 03    	staA 	displayBcdC
0109   7828             	
0110   7828 86 00       	ldaA	#00000000b	;select direction (3rd bit = 0)
0111   782A B7 24 01    	staA 	lampRowC
0112   782D 86 FF       	ldaA 	#11111111b	;set to output
0113   782F B7 24 00    	staA 	lampRow
0114   7832 86 04       	ldaA 	#00000100b 	;select data (3rb bit = 1)
0115   7834 B7 24 01    	staA 	lampRowC
0116   7837             	
0117   7837 86 00       	ldaA	#00000000b	;select direction (3rd bit = 0)
0118   7839 B7 24 03    	staA 	lampStrobeC
0119   783C 86 FF       	ldaA 	#11111111b	;set to output
0120   783E B7 24 02    	staA 	lampStrobe
0121   7841 86 04       	ldaA 	#00000100b 	;select data (3rb bit = 1)
0122   7843 B7 24 03    	staA 	lampStrobeC
0123   7846             	
0124   7846 86 00       	ldaA	#00000000b	;select direction (3rd bit = 0)
0125   7848 B7 30 03    	staA 	switchStrobeC
0126   784B 86 FF       	ldaA 	#11111111b	;set to output
0127   784D B7 30 02    	staA 	switchStrobe
0128   7850 86 04       	ldaA 	#00000100b 	;select data (3rb bit = 1)
0129   7852 B7 30 03    	staA 	switchStrobeC
0130   7855             	
0131   7855 86 00       	ldaA	#00000000b	;select direction (3rd bit = 0)
0132   7857 B7 30 01    	staA 	switchRowC
0133   785A 86 00       	ldaA 	#00000000b	;set to input
0134   785C B7 30 00    	staA 	switchRow
0135   785F 86 04       	ldaA 	#00000100b 	;select data (3rb bit = 1)
0136   7861 B7 30 01    	staA 	switchRowC
0137   7864             	
0138   7864 86 00       	ldaA	#00000000b	;select direction (3rd bit = 0)
0139   7866 B7 22 01    	staA 	solenoidAC
0140   7869 B7 22 03    	staA	solenoidBC
0141   786C 86 FF       	ldaA 	#11111111b	;set to output
0142   786E B7 22 00    	staA 	solenoidA
0143   7871 B7 22 02    	staA 	solenoidB
0144   7874 86 04       	ldaA 	#00000100b 	;select data (3rb bit = 1)
0145   7876 B7 22 01    	staA 	solenoidAC
0146   7879 B7 22 03    	staA 	solenoidBC
0147   787C             	
0148   787C             ;
0149   787C             
0150   787C 86 00       	ldaA	#00
0151   787E D7 10       	staB	displayBcd1
0152   7880             	
0153   7880 86 FF       	ldaA	#$FF	
0154   7882 B7 28 00    	staA 	displayStrobe
0155   7885             
0156   7885 86 00       	ldaA	#00
0157   7887 97 07       	staA	strobe
0158   7889             	
0159   7889 CE 00 00    	ldX 	#0
0160   788C DF 50       	stX		curCol
0161   788E             	
0162   788E 86 00       	ldaA	#0
0163   7890 97 52       	staA	curSwitchRowLsb
0164   7892             	
0165   7892             ; fill solenoid status with off
0166   7892 86 FF       	ldaA	#$FF
0167   7894 CE 01 40    	ldX		#solenoid1
0168   7897             lSolDefault:
0169   7897 A7 00       	staA	0, X
0170   7899 08          	inX
0171   789A 8C 01 4F    	cpX		#solenoid16
0172   789D 2F F8       	ble		lSolDefault
0173   789F             	
0174   789F             ; empty settle
0175   789F 86 00       	ldaA	#$00
0176   78A1 CE 01 00    	ldX		#settleRow1
0177   78A4             lSettleDefault:
0178   78A4 A7 00       	staA		0, X
0179   78A6 08          	inX
0180   78A7 8C 08 46    	cpX		#settleRow8 + 7
0181   78AA 2F F8       	ble		lSettleDefault
0182   78AC             	
0183   78AC             ; setup complete
0184   78AC 0E          	clI		; enable timer interrupt
0185   78AD             	
0186   78AD             	
0187   78AD             end:
0188   78AD 7E 78 AD    	jmp		end
0189   78B0 00 00       	.dw 0
0190   78B2 00 00       	.dw 0
0191   78B4 00 00       	.dw 0
0192   78B6 00 00       	.dw 0
0193   78B8 00 00       	.dw 0
0194   78BA             		
0195   78BA             interrupt:	
0196   78BA 7C 00 02    	inc		counter
0197   78BD 86 00       	ldaA	#0
0198   78BF 91 02       	cmpA	counter
0199   78C1 26 25       	bne		counterHandled
0200   78C3 7C 00 03    	inc 	counter2
0201   78C6 86 04       	ldaA	#4
0202   78C8 91 03       	cmpA	counter2
0203   78CA 26 1C       	bne		counterHandled
0204   78CC             	
0205   78CC 86 00       	ldaA	#0
0206   78CE 97 03       	staA	counter2
0207   78D0 86 77       	ldaA	#01110111b
0208   78D2 91 10       	cmpA	displayBcd1
0209   78D4 27 0A       	beq		on
0210   78D6             	
0211   78D6 86 F0       	ldaA	#$F0
0212   78D8 97 08       	staA	lampRow1
0213   78DA 86 77       	ldaA	#01110111b
0214   78DC 97 10       	staA	displayBcd1	
0215   78DE 20 08       	bra		counterHandled
0216   78E0             on:
0217   78E0 86 0F       	ldaA	#$0F
0218   78E2 97 08       	staA	lampRow1
0219   78E4 86 33       	ldaA	#00110011b
0220   78E6 97 10       	staA	displayBcd1	
0221   78E8             
0222   78E8             counterHandled:
0223   78E8             ; move switch column
0224   78E8 96 07       	ldaA	strobe
0225   78EA B7 30 02    	staA	switchStrobe
0226   78ED             	
0227   78ED             ; update display 
0228   78ED 86 F0       	ldaA	#11110000b	
0229   78EF 9A 02       	oraA	counter
0230   78F1 C6 FF       	ldaB 	#$FF
0231   78F3 F7 28 02    	staB	displayBcd
0232   78F6 B7 28 00    	staA	displayStrobe
0233   78F9 D6 10       	ldaB	displayBcd1
0234   78FB F7 28 02    	staB	displayBcd
0235   78FE             	
0236   78FE             ; read switches
0237   78FE DE 50       	ldX		curCol
0238   7900 B6 30 00    	ldaA	switchRow
0239   7903 16          	tab
0240   7904 A8 20       	eorA	switchRow1, X ; A contains any switches that have changed state
0241   7906             	
0242   7906 D6 52       	ldaB	curSwitchRowLsb 	;	B now contains LSB of switchTable row addr
0243   7908 D7 01       	staB	temp + 1 			; temp = switch
0244   790A D7 54       	staB	tempX + 1			; tempX = cRAM
0245   790C C6 60       	ldaB	#switchTable >> 8
0246   790E D7 00       	staB	temp
0247   7910 C6 01       	ldaB	#cRAM >> 8
0248   7912 D7 53       	staB	tempX
0249   7914             	
0250   7914 C6 01       	ldaB	#00000001b
0251   7916             	
0252   7916             	; temp now contains the beginning of the row in the switchTable
0253   7916             swNext:
0254   7916 85 01       	bitA	#00000001b	 ; Z set if switch not different
0255   7918             	ifne		; if bit set, switch different
0255   7918             
0255   7918 27 FE       
0256   791A 36          		pshA
0257   791B DE 53       		ldX		tempX
0258   791D A6 00       		ldaA	0, X
0259   791F 84 0F       		andA	#00001111b ; need to remove upper F ( sets Z if A = 0)
0260   7921             		ifne 	; >0 -> settling
0260   7921             
0260   7921 27 FE       
0261   7923 4A          			decA
0262   7924 A7 00       			staA	0, X	; sets Z if now A = 0
0263   7926             			ifeq ; now settled, fire event
0263   7926             
0263   7926 26 FE       
0264   7928 DE 50       settled:		ldX		curCol
0265   792A 17          				tBA
0266   792B A8 20       				eorA	switchRow1, X ; toggle bit in row
0267   792D A7 20       				staA	switchRow1, X
0268   792F             				; todo somehow actually fire it here
0269   792F             				;ldX		temp	
0270   792F             				;ldX		0, X
0271   792F             				;jsr		0, X
0272   792F             			endif
0272   792F             
0272   792F             
0272   792F             
0272   792F             
0272   792F             
0272   792F~            			endif
0272   792F~            			endif
0272   792F             
0272   792F~            			endif
0272   792F~            			endif
0272   792F             
0272   7927             
0272   7927 07          
0272   7928             
0272   7928             
0272   7928~            			endif
0272   7928~            			endif
0272   7928~            			endif
0272   7928             
0272   792F             
0272   792F~            			endif
0272   792F~            			endif
0272   792F             
0273   792F             		else ; =0 -> was settled, so now it's not
0273   792F             
0273   792F             
0273   792F             
0273   792F             
0273   7922             
0273   7922             
0273   7922             
0273   7922~            		else ; =0 -> was settled, so now it's not
0273   7922~            		else ; =0 -> was settled, so now it's not
0273   7922~            		else ; =0 -> was settled, so now it's not
0273   7922~            		else ; =0 -> was settled, so now it's not
0273   7922             
0273   7922~            		else ; =0 -> was settled, so now it's not
0273   7922~            		else ; =0 -> was settled, so now it's not
0273   7922~            		else ; =0 -> was settled, so now it's not
0273   7922~            		else ; =0 -> was settled, so now it's not
0273   7922             
0273   7922             
0273   7922 0E          
0273   792F             
0273   792F 20 FE       
0273   7931             
0273   7931             
0273   7931             
0273   7931~            		else ; =0 -> was settled, so now it's not
0273   7931~            		else ; =0 -> was settled, so now it's not
0273   7931~            		else ; =0 -> was settled, so now it's not
0273   7931~            		else ; =0 -> was settled, so now it's not
0273   7931~            		else ; =0 -> was settled, so now it's not
0273   7931             
0273   7931~            		else ; =0 -> was settled, so now it's not
0273   7931~            		else ; =0 -> was settled, so now it's not
0273   7931             
0273   7931~            		else ; =0 -> was settled, so now it's not
0273   7931~            		else ; =0 -> was settled, so now it's not
0273   7931             
0274   7931             			; get the settle time
0275   7931 96 54       			ldaA	tempX + 1
0276   7933 97 01       			staA	temp + 1 ;get temp in sync with tempX LSB
0277   7935 DE 00       			ldX		temp
0278   7937 A6 80       			ldaA	settleTable - switchTable, X ; A has settle settings
0279   7939 DE 53       			ldX		tempX
0280   793B A7 00       			staA	0, X		; start settling	
0281   793D 27 E9       			beq		settled		; quick out for 0 settle
0282   793F             		endif
0282   793F             
0282   793F             
0282   793F             
0282   793F             
0282   793F             
0282   793F~            		endif
0282   793F~            		endif
0282   793F             
0282   793F~            		endif
0282   793F~            		endif
0282   793F             
0282   7930             
0282   7930 0E          
0282   7931             
0282   7931             
0282   7931~            		endif
0282   7931~            		endif
0282   7931~            		endif
0282   7931             
0282   793F             
0282   793F~            		endif
0282   793F~            		endif
0282   793F             
0283   793F             			
0284   793F 32          		pulA
0285   7940             	endif
0285   7940             
0285   7940             
0285   7940             
0285   7940             
0285   7940             
0285   7940~            	endif
0285   7940~            	endif
0285   7940             
0285   7940~            	endif
0285   7940~            	endif
0285   7940             
0285   7919             
0285   7919 26          
0285   791A             
0285   791A             
0285   791A~            	endif
0285   791A~            	endif
0285   791A~            	endif
0285   791A             
0285   7940             
0285   7940~            	endif
0285   7940~            	endif
0285   7940             
0286   7940 7C 00 54    	inc tempX + 1
0287   7943 58          	aslB
0288   7944 44          	lsrA			; pop lowest bit off, set Z if A is empty
0289   7945 26 CF       	bne		swNext 	; more on bits, keep processing 
0290   7947             	
0291   7947             	
0292   7947             ; update lamps
0293   7947 DE 50       	ldX		curCol
0294   7949 86 FF       	ldaA	#$FF	;lamp row is inverted
0295   794B B7 24 00    	staA	lampRow
0296   794E 96 07       	ldaA	strobe
0297   7950 B7 24 02    	staA	lampStrobe
0298   7953 A6 20       	ldaA	switchRow1, X
0299   7955 B7 24 00    	staA	lampRow
0300   7958 86 00       	ldaA	#00
0301   795A             
0302   795A             ; update solenoids
0303   795A             	; if a solenoid is set to <254, --
0304   795A             	; if =255, off, otherwise on
0305   795A             	; leave it at 254
0306   795A             	
0307   795A 7C 00 50    	inc		curCol	; indexed can't use base >255, so temp inc X by 255 (1 MSB)
0308   795D 86 FE       	ldaA	#254
0309   795F DE 50       	ldX		curCol
0310   7961 E6 40       	ldaB	solenoid1 - cRAM, X
0311   7963 A1 40       	cmpA	solenoid1 - cRAM, X
0312   7965             	ifge 	; solenoid <=254, turn on
0312   7965             
0312   7965 25 FE       
0313   7967             		ifgt	; solenoid < 254, decrement
0313   7967             
0313   7967 23 FE       
0314   7969 6A 40       			dec		solenoid1 - cRAM, X
0315   796B             		endif
0315   796B             
0315   796B             
0315   796B             
0315   796B             
0315   796B             
0315   796B~            		endif
0315   796B~            		endif
0315   796B             
0315   796B~            		endif
0315   796B~            		endif
0315   796B             
0315   7968             
0315   7968 02          
0315   7969             
0315   7969             
0315   7969~            		endif
0315   7969~            		endif
0315   7969~            		endif
0315   7969             
0315   796B             
0315   796B~            		endif
0315   796B~            		endif
0315   796B             
0316   796B 0D          		sec
0317   796C             	else
0317   796C             
0317   796C             
0317   796C             
0317   796C             
0317   7966             
0317   7966             
0317   7966             
0317   7966~            	else
0317   7966~            	else
0317   7966~            	else
0317   7966~            	else
0317   7966             
0317   7966~            	else
0317   7966~            	else
0317   7966~            	else
0317   7966~            	else
0317   7966             
0317   7966             
0317   7966 07          
0317   796C             
0317   796C 20 FE       
0317   796E             
0317   796E             
0317   796E             
0317   796E~            	else
0317   796E~            	else
0317   796E~            	else
0317   796E~            	else
0317   796E~            	else
0317   796E             
0317   796E~            	else
0317   796E~            	else
0317   796E             
0317   796E~            	else
0317   796E~            	else
0317   796E             
0318   796E 0C          		clc
0319   796F             	endif
0319   796F             
0319   796F             
0319   796F             
0319   796F             
0319   796F             
0319   796F~            	endif
0319   796F~            	endif
0319   796F             
0319   796F~            	endif
0319   796F~            	endif
0319   796F             
0319   796D             
0319   796D 01          
0319   796E             
0319   796E             
0319   796E~            	endif
0319   796E~            	endif
0319   796E~            	endif
0319   796E             
0319   796F             
0319   796F~            	endif
0319   796F~            	endif
0319   796F             
0320   796F 76 00 28    	ror		solAStatus
0321   7972 A1 48       	cmpA	solenoid9 - cRAM, X
0322   7974             	ifge 	; solenoid <=254, turn on
0322   7974             
0322   7974 25 FE       
0323   7976             		ifgt	; solenoid < 254, decrement
0323   7976             
0323   7976 23 FE       
0324   7978 6A 48       			dec		solenoid9 - cRAM, X
0325   797A             		endif
0325   797A             
0325   797A             
0325   797A             
0325   797A             
0325   797A             
0325   797A~            		endif
0325   797A~            		endif
0325   797A             
0325   797A~            		endif
0325   797A~            		endif
0325   797A             
0325   7977             
0325   7977 02          
0325   7978             
0325   7978             
0325   7978~            		endif
0325   7978~            		endif
0325   7978~            		endif
0325   7978             
0325   797A             
0325   797A~            		endif
0325   797A~            		endif
0325   797A             
0326   797A 0D          		sec
0327   797B             	else
0327   797B             
0327   797B             
0327   797B             
0327   797B             
0327   7975             
0327   7975             
0327   7975             
0327   7975~            	else
0327   7975~            	else
0327   7975~            	else
0327   7975~            	else
0327   7975             
0327   7975~            	else
0327   7975~            	else
0327   7975~            	else
0327   7975~            	else
0327   7975             
0327   7975             
0327   7975 07          
0327   797B             
0327   797B 20 FE       
0327   797D             
0327   797D             
0327   797D             
0327   797D~            	else
0327   797D~            	else
0327   797D~            	else
0327   797D~            	else
0327   797D~            	else
0327   797D             
0327   797D~            	else
0327   797D~            	else
0327   797D             
0327   797D~            	else
0327   797D~            	else
0327   797D             
0328   797D 0C          		clc
0329   797E             	endif
0329   797E             
0329   797E             
0329   797E             
0329   797E             
0329   797E             
0329   797E~            	endif
0329   797E~            	endif
0329   797E             
0329   797E~            	endif
0329   797E~            	endif
0329   797E             
0329   797C             
0329   797C 01          
0329   797D             
0329   797D             
0329   797D~            	endif
0329   797D~            	endif
0329   797D~            	endif
0329   797D             
0329   797E             
0329   797E~            	endif
0329   797E~            	endif
0329   797E             
0330   797E 76 00 29    	ror		solBStatus
0331   7981 7A 00 50    	dec		curCol
0332   7984             	
0333   7984             ; update strobe	
0334   7984 DE 50       	ldX		curCol
0335   7986 08          	inX 	
0336   7987 86 08       	ldaA	#8 	; pitch
0337   7989 9B 52       	addA	curSwitchRowLsb
0338   798B 97 52       	staA	curSwitchRowLsb
0339   798D 78 00 07    	asl		strobe
0340   7990 86 00       	ldaA	#0
0341   7992 91 07       	cmpA	strobe ; strobe done?  reset
0342   7994             	ifeq		
0342   7994             
0342   7994 26 FE       
0343   7996 96 28       		ldaA	solAStatus
0344   7998 B7 22 00    		staA	solenoidA
0345   799B 96 29       		ldaA	solBStatus
0346   799D B7 22 02    		staA	solenoidB
0347   79A0             	
0348   79A0 86 01       		ldaA	#00000001b
0349   79A2 97 07       		staA	strobe
0350   79A4             		
0351   79A4 CE 00 00    		ldX 	#0
0352   79A7             		
0353   79A7 86 00       		ldaA	#0
0354   79A9 97 52       		staA	curSwitchRowLsb
0355   79AB 97 28       		staA	solAStatus
0356   79AD 97 29       		staA	solBStatus
0357   79AF             	endif
0357   79AF             
0357   79AF             
0357   79AF             
0357   79AF             
0357   79AF             
0357   79AF~            	endif
0357   79AF~            	endif
0357   79AF             
0357   79AF~            	endif
0357   79AF~            	endif
0357   79AF             
0357   7995             
0357   7995 19          
0357   7996             
0357   7996             
0357   7996~            	endif
0357   7996~            	endif
0357   7996~            	endif
0357   7996             
0357   79AF             
0357   79AF~            	endif
0357   79AF~            	endif
0357   79AF             
0358   79AF             	
0359   79AF DF 50       	stX		curCol
0360   79B1 3B          	rti
0361   79B2             
0362   7FF8             pointers: 	.org $7FF8  	
0363   7FF8             	.msfirst
0364   7FF8 78 BA       	.dw interrupt			
0365   7FFA 78 BA       	.dw interrupt			
0366   7FFC 78 BA       	.dw interrupt			
0367   7FFE 78 00       	.dw main
0368   8000             	
0369   8000             	
0370   8000             	.endtasm: Number of errors = 0
