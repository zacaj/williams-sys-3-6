0001   0000             #include "680xlogic.asm"
0001+  0000             ;***********************************************
0002+  0000             ;* 680X Style Logical Instruction Macros       *
0003+  0000             ;* For use with TASMx Assembler                *
0004+  0000             ;* Written by Jess M. Askey 2001 jess@askey.org*
0005+  0000             ;***********************************************
0006+  0000             .module logic
0007+  0000             
0008+  0000             var1_		.equ	$00
0009+  0000             var2_		.equ	$00
0010+  0000             var3_		.equ	$00
0011+  0000             var4_		.equ	$00
0012+  0000             
0013+  0000             #define     FLAG_IF    	0
0014+  0000             #define     FLAG_ELSE 	1
0015+  0000             #define	FLAG_BEGIN 	2
0016+  0000             
0017+  0000             ;*******************************************************************
0018+  0000             ;* Locate: Pushes two Words                                        *
0019+  0000             ;*                                                                 *
0020+  0000             ;*            Word 1 - address of branch location                  *
0021+  0000             ;*            Word 2 - Type of Operation                           *
0022+  0000             ;*                     0 - Standard ENDIF                          *
0023+  0000             ;*                     1 - ELSE or Logical ELSE                    *
0024+  0000             ;*                     2 - Loop                                    *
0025+  0000             ;*******************************************************************
0026+  0000             #define	logic_loc(type)	     \ .push  *, type
0027+  0000             
0028+  0000             ;*******************************************************************
0029+  0000             ;* Ifxx: These are the standard 'if' statements, they will always  *
0030+  0000             ;*       be of type 0.                                             *
0031+  0000             ;*******************************************************************
0032+  0000             #define	logic_ifxx(x)	     logic_loc(FLAG_IF) \ x  * 
0033+  0000             
0034+  0000             ;*******************************************************************
0035+  0000             ;* Begin: The start marker for logical loops, must terminate with  *
0036+  0000             ;*        an 'xxend' statement.                                    *
0037+  0000             ;******************************************************************* 
0038+  0000             #define     begin(x)		     logic_loc(FLAG_BEGIN)
0039+  0000             
0040+  0000             ;*******************************************************************
0041+  0000             ;* Logic End: This is the end macro for the 'begin' statement. It  *
0042+  0000             ;*            pulls the pc location of the beginning of the loop   *
0043+  0000             ;*            and verifies that the 'type' is correct.             *
0044+  0000             ;*******************************************************************
0045+  0000             #define logic_loopend(x,y)	\ .pop var1_, var2_
0046+  0000             #defcont				\#if (var1_ & FLAG_BEGIN)
0047+  0000             #defcont					\#if ((var2_-*-2+127) <= 0)
0048+  0000             #defcont						\ y	*+5
0049+  0000             #defcont						\ jmp	var2_
0050+  0000             #defcont					\#else
0051+  0000             #defcont						\ x	var2_
0052+  0000             #defcont					\#endif
0053+  0000             #defcont				\#else
0054+  0000             #defcont					\ .error "Inappropriate End for BEGIN Loop."
0055+  0000             #defcont				\#endif
0056+  0000             
0057+  0000             ;*******************************************************************
0058+  0000             ;* Logic Find: Used for ENDIF statement. Will find the pc for the  *
0059+  0000             ;*             previous IF (or ELSE) and update the branch or jump *
0060+  0000             ;*             at that address to point to the current address.    *
0061+  0000             ;*******************************************************************
0062+  0000             #define logic_end \var1_ .set *
0063+  0000             #defcont		\ .pop var3_, var4_
0064+  0000             #defcont		\#if (var3_ & FLAG_BEGIN)==0 
0065+  0000             #defcont			\#if (var3_ & FLAG_ELSE)==0	
0066+  0000             #defcont  				\var2_ .set var1_-var4_-2
0067+  0000             #defcont				\#if var2_+127 < 0
0068+  0000             #defcont					\ .error "Branch Range < -127"
0069+  0000             #defcont				\#else
0070+  0000             #defcont					\#if var2_-128 > 0
0071+  0000             #defcont						\ .error "Branch Range > 128"
0072+  0000             #defcont					\#else
0073+  0000             #defcont    					\ .org var4_+1
0074+  0000             #defcont						\ .byte var2_
0075+  0000             #defcont					\#endif
0076+  0000             #defcont				\#endif
0077+  0000             #defcont			\#else	
0078+  0000             #defcont    			\ .org  var4_-2	
0079+  0000             #defcont				\ .word var1_
0080+  0000             #defcont			\#endif
0081+  0000             #defcont			\ .org	var1_
0082+  0000             #defcont		\#else
0083+  0000             #defcont			\.error "Wrong Endtype for IF block"
0084+  0000             #defcont		\#endif
0085+  0000             
0086+  0000             ;*******************************************************************
0087+  0000             ;* Logic Else: Can act as a standard else or a complex else        *
0088+  0000             ;*             (ie. with additional logic as defined below). The   *
0089+  0000             ;*             ELSE block will resove how to terminate the current *
0090+  0000             ;*             code and then set the owning IF statement's data    *
0091+  0000             ;*             byte.                                               *
0092+  0000             ;*******************************************************************
0093+  0000             #define	logic_else(x,y)	\var1_ .set $
0094+  0000             #defcont		\ .pop var3_, var4_
0095+  0000             #defcont		\#if (var3_ & FLAG_BEGIN)==0
0096+  0000             #defcont			\#if (var3_ & FLAG_ELSE)==0
0097+  0000             #defcont				\ .org var4_+1
0098+  0000             #defcont	      		\#if x==0
0099+  0000             #defcont					\var2_ .set var1_-var4_-2+2
0100+  0000             #defcont					\#if var2_+127 < 0
0101+  0000             #defcont						\ .org var1_
0102+  0000             #defcont						\.push $+3, 1
0103+  0000             #defcont						\ jmp $
0104+  0000             #defcont					\#else
0105+  0000             #defcont						\#if var2_-128>0
0106+  0000             #defcont							\ .org var1_
0107+  0000             #defcont							\.push $+3, 1
0108+  0000             #defcont							\ jmp $
0109+  0000             #defcont						\#else
0110+  0000             #defcont							\.push var1_, 0
0111+  0000             #defcont							\ .byte var2_
0112+  0000             #defcont							\ .org var1_
0113+  0000             #defcont							\ BRA $
0114+  0000             #defcont							\ .org var1_+2
0115+  0000             #defcont						\#endif
0116+  0000             #defcont					\#endif
0117+  0000             #defcont				\#else
0118+  0000             #defcont					\ .byte var1_-var4_-2+2
0119+  0000             #defcont					\ .org var1_
0120+  0000             #defcont					\.push $, 0
0121+  0000             #defcont					\ y $		
0122+  0000             #defcont				\#endif
0123+  0000             #defcont			\#else
0124+  0000             #defcont				\.error "Duplicate ELSE Statement"
0125+  0000             #defcont			\#endif
0126+  0000             #defcont		\#else
0127+  0000             #defcont			\ .error "Misplaced Else"
0128+  0000             #defcont		\#endif
0129+  0000             
0130+  0000             
0131+  0000             ;*******************************************************************
0132+  0000             ;* Defines how to use the various logic macros defined above.      *
0133+  0000             ;*******************************************************************
0134+  0000             #define	ifeq	logic_ifxx(BNE)		
0135+  0000             #define	ifne	logic_ifxx(BEQ)
0136+  0000             #define	ifpl	logic_ifxx(BMI)
0137+  0000             #define	ifhi	logic_ifxx(BLO)
0138+  0000             #define	ifmi	logic_ifxx(BPL)
0139+  0000             #define	iflo	logic_ifxx(BHI)
0140+  0000             #define	ifcs	logic_ifxx(BCC)
0141+  0000             #define	ifcc	logic_ifxx(BCS)
0142+  0000             #define 	ifvc	logic_ifxx(BVS)
0143+  0000             #define 	ifvs	logic_ifxx(BVC)
0144+  0000             #define	ifge	logic_ifxx(BLO)
0145+  0000             #define	ifgt	logic_ifxx(BLS)
0146+  0000             
0147+  0000             #define	else  	logic_else(0,0)
0148+  0000             #define	else_eq	logic_else(1,BEQ)
0149+  0000             #define	else_ne	logic_else(1,BNE)
0150+  0000             #define	else_pl	logic_else(1,BPL)
0151+  0000             #define	else_mi	logic_else(1,BMI)
0152+  0000             #define	else_cc	logic_else(1,BCC)
0153+  0000             #define	else_cs	logic_else(1,BCS)
0154+  0000             
0155+  0000             #define 	endif		logic_end
0156+  0000             
0157+  0000             #define	eqend	logic_loopend(BNE,BEQ)		
0158+  0000             #define	neend	logic_loopend(BEQ,BNE)		
0159+  0000             #define	plend	logic_loopend(BMI,BPL)
0160+  0000             #define	miend	logic_loopend(BPL,BMI)
0161+  0000             #define	csend	logic_loopend(BCC,BCS)
0162+  0000             #define	ccend	logic_loopend(BCS,BCC)
0163+  0000             #define	vcend	logic_loopend(BVS,BVC)
0164+  0000             #define	vsend	logic_loopend(BVC,BVS)
0165+  0000             
0166+  0000             #define	loopend	logic_loopend(BRA,BRA)
0167+  0000             
0168+  0000             #define	lsb(x)	x&$FF
0169+  0000             
0170+  0000             #define	msb(x)	(x>>8)&$FF0002   0000             
0003   0000             displayStrobe: 	.equ $2800
0004   0000             displayBcd: 	.equ $2802
0005   0000             displayStrobeC:	.equ $2801
0006   0000             displayBcdC:	.equ $2803
0007   0000             lampRow:		.equ $2400
0008   0000             lampRowC:		.equ $2401
0009   0000             lampStrobe:		.equ $2402
0010   0000             lampStrobeC:	.equ $2403
0011   0000             switchStrobe:	.equ $3002
0012   0000             switchStrobeC:	.equ $3003
0013   0000             switchRow:		.equ $3000
0014   0000             switchRowC:		.equ $3001
0015   0000             solenoidA:		.equ $2200
0016   0000             solenoidAC		.equ $2201
0017   0000             solenoidB:		.equ $2202
0018   0000             solenoidBC:		.equ $2203
0019   0000             
0020   0000             RAM:			.equ $0000
0021   0000             cRAM:			.equ $0100
0022   0000             temp:			.equ RAM + $00
0023   0000             counter:		.equ RAM + $02
0024   0000             counter2:		.equ RAM + $03
0025   0000             strobe:			.equ RAM + $07
0026   0000             lampRow1:		.equ RAM + $08
0027   0000             lampRow8:		.equ lampRow1 + 7 
0028   0000             displayBcd1:	.equ RAM + $10
0029   0000             displayBcd16:	.equ RAM + $1F
0030   0000             switchRow1:		.equ RAM + $20
0031   0000             switchRow8:		.equ switchRow1 + 7 
0032   0000             solAStatus:		.equ RAM + $28
0033   0000             solBStatus:		.equ RAM + $29
0034   0000             curCol:			.equ RAM + $50
0035   0000             curSwitchRowLsb	.equ RAM + $52
0036   0000             tempX:			.equ RAM + $53
0037   0000             tempQ:			.equ RAM + $54 ; 55
0038   0000             
0039   0000             queue:			.equ RAM + $60	; closed | switch? | number#6
0040   0000             queueLast:		.equ RAM + $6F
0041   0000             
0042   0000             settleRow1:		.equ cRAM + $00
0043   0000             settleRow8:		.equ settleRow1+  8*8-1
0044   0000             solenoid1:		.equ cRAM + $40
0045   0000             solenoid8:		.equ solenoid1 + 7
0046   0000             solenoid9:		.equ solenoid1 + 8
0047   0000             solenoid16:		.equ solenoid1 + 15
0048   0000             pA_10:			.equ cRAM + $50
0049   0000             pA_1m:			.equ pA_10 + 5
0050   0000             pB_10:			.equ pA_1m + 1
0051   0000             pB_1m:			.equ pB_10 + 5
0052   0000             pC_10:			.equ pB_1m + 1
0053   0000             pC_1m:			.equ pC_10 + 5
0054   0000             pD_10:			.equ pC_1m + 1
0055   0000             pD_1m:			.equ pD_10 + 5  
0056   0000             displayCol:		.equ cRAM + $68
0057   0000             state:			.equ cRAM + $69	; gameover | ? | ? | ?
0058   0000             queueStart:		.equ cRAM + $70
0059   0000             queueEnd:		.equ cRAM + $71
0060   0000             
0061   0000             instant:		.equ 4
0062   0000             debounce:		.equ 1
0063   0000             slow:			.equ 2
0064   0000             
0065   0000             switchSettle:	.equ cRAM + $30
0066   0000             ; through $7F ?
0067   0000             
0068   6100             none:	.org $6000 + 256
0069   6100 39          	rts
0070   6101             	
0071   6101             	.msfirst
0072   6000             callbackTable: 	.org $6000
0073   6000 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0073   6002 61 00       
0073   6004 61 00       
0073   6006 61 00       
0073   6008 61 00       
0073   600A 61 00       
0073   600C 61 00       
0073   600E 61 00       
0074   6010 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0074   6012 61 00       
0074   6014 61 00       
0074   6016 61 00       
0074   6018 61 00       
0074   601A 61 00       
0074   601C 61 00       
0074   601E 61 00       
0075   6020 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0075   6022 61 00       
0075   6024 61 00       
0075   6026 61 00       
0075   6028 61 00       
0075   602A 61 00       
0075   602C 61 00       
0075   602E 61 00       
0076   6030 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0076   6032 61 00       
0076   6034 61 00       
0076   6036 61 00       
0076   6038 61 00       
0076   603A 61 00       
0076   603C 61 00       
0076   603E 61 00       
0077   6040 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0077   6042 61 00       
0077   6044 61 00       
0077   6046 61 00       
0077   6048 61 00       
0077   604A 61 00       
0077   604C 61 00       
0077   604E 61 00       
0078   6050 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0078   6052 61 00       
0078   6054 61 00       
0078   6056 61 00       
0078   6058 61 00       
0078   605A 61 00       
0078   605C 61 00       
0078   605E 61 00       
0079   6060 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0079   6062 61 00       
0079   6064 61 00       
0079   6066 61 00       
0079   6068 61 00       
0079   606A 61 00       
0079   606C 61 00       
0079   606E 61 00       
0080   6070 61 00       	.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none\.dw none
0080   6072 61 00       
0080   6074 61 00       
0080   6076 61 00       
0080   6078 61 00       
0080   607A 61 00       
0080   607C 61 00       
0080   607E 61 00       
0081   6080             ; on = how many cycles it must be on for before registering (1 cycle = 16ms (?)) (max 7)
0082   6080             ; off = how many cycles it must be off for
0083   6080             ; onOnly = if true, don't notify of an off event (also set off = 0 for efficiency)
0084   6080             ; gameover = whether the switch is active in gameover mode (these callbacks must check whether in game over when triggered)
0085   6080             #define SW(on,off,onOnly,gameover) .db (gameover<<7)(onOnly<<6)|(on<<3)|(off) 
0086   6080             settleTable: ; must be right after callbackTable
0087   6080 07          	SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)
0087   6081 07          
0087   6082 07          
0087   6083 07          
0087   6084 07          
0087   6085 07          
0087   6086 07          
0087   6087 07          
0088   6088 07          	SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)
0088   6089 07          
0088   608A 07          
0088   608B 07          
0088   608C 07          
0088   608D 07          
0088   608E 07          
0088   608F 07          
0089   6090 07          	SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)
0089   6091 07          
0089   6092 07          
0089   6093 07          
0089   6094 07          
0089   6095 07          
0089   6096 07          
0089   6097 07          
0090   6098 07          	SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)
0090   6099 07          
0090   609A 07          
0090   609B 07          
0090   609C 07          
0090   609D 07          
0090   609E 07          
0090   609F 07          
0091   60A0 07          	SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)
0091   60A1 07          
0091   60A2 07          
0091   60A3 07          
0091   60A4 07          
0091   60A5 07          
0091   60A6 07          
0091   60A7 07          
0092   60A8 07          	SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)
0092   60A9 07          
0092   60AA 07          
0092   60AB 07          
0092   60AC 07          
0092   60AD 07          
0092   60AE 07          
0092   60AF 07          
0093   60B0 07          	SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)
0093   60B1 07          
0093   60B2 07          
0093   60B3 07          
0093   60B4 07          
0093   60B5 07          
0093   60B6 07          
0093   60B7 07          
0094   60B8 07          	SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)\SW(0,7,0,1)
0094   60B9 07          
0094   60BA 07          
0094   60BB 07          
0094   60BC 07          
0094   60BD 07          
0094   60BE 07          
0094   60BF 07          
0095   60C0             	
0096   7800             main:		.org $7800
0097   7800             	
0098   7800 86 00       	ldaA 	#0
0099   7802 97 00       	staA	temp
0100   7804 86 FF       	ldaA	#$FF
0101   7806 97 01       	staA	temp + 1
0102   7808 9E 00       	ldS		temp
0103   780A             
0104   780A             test:
0105   780A             	
0106   780A             piaSetup:
0107   780A 86 00       	ldaA	#00000000b	;select direction (3rd bit = 0)
0108   780C B7 28 01    	staA 	displayStrobeC
0109   780F 86 3F       	ldaA 	#00111111b	;set LED pins to outputs
0110   7811 B7 28 00    	staA 	displayStrobe
0111   7814 86 04       	ldaA 	#00000100b 	;select data (3rb bit = 1)
0112   7816 B7 28 01    	staA 	displayStrobeC
0113   7819             	
0114   7819 86 00       	ldaA	#00000000b	;select direction (3rd bit = 0)
0115   781B B7 28 03    	staA 	displayBcdC
0116   781E 86 FF       	ldaA 	#11111111b	;set display BCD to output
0117   7820 B7 28 02    	staA 	displayBcd
0118   7823 86 04       	ldaA 	#00000100b 	;select data (3rb bit = 1)
0119   7825 B7 28 03    	staA 	displayBcdC
0120   7828             	
0121   7828 86 00       	ldaA	#00000000b	;select direction (3rd bit = 0)
0122   782A B7 24 01    	staA 	lampRowC
0123   782D 86 FF       	ldaA 	#11111111b	;set to output
0124   782F B7 24 00    	staA 	lampRow
0125   7832 86 04       	ldaA 	#00000100b 	;select data (3rb bit = 1)
0126   7834 B7 24 01    	staA 	lampRowC
0127   7837             	
0128   7837 86 00       	ldaA	#00000000b	;select direction (3rd bit = 0)
0129   7839 B7 24 03    	staA 	lampStrobeC
0130   783C 86 FF       	ldaA 	#11111111b	;set to output
0131   783E B7 24 02    	staA 	lampStrobe
0132   7841 86 04       	ldaA 	#00000100b 	;select data (3rb bit = 1)
0133   7843 B7 24 03    	staA 	lampStrobeC
0134   7846             	
0135   7846 86 00       	ldaA	#00000000b	;select direction (3rd bit = 0)
0136   7848 B7 30 03    	staA 	switchStrobeC
0137   784B 86 FF       	ldaA 	#11111111b	;set to output
0138   784D B7 30 02    	staA 	switchStrobe
0139   7850 86 04       	ldaA 	#00000100b 	;select data (3rb bit = 1)
0140   7852 B7 30 03    	staA 	switchStrobeC
0141   7855             	
0142   7855 86 00       	ldaA	#00000000b	;select direction (3rd bit = 0)
0143   7857 B7 30 01    	staA 	switchRowC
0144   785A 86 00       	ldaA 	#00000000b	;set to input
0145   785C B7 30 00    	staA 	switchRow
0146   785F 86 04       	ldaA 	#00000100b 	;select data (3rb bit = 1)
0147   7861 B7 30 01    	staA 	switchRowC
0148   7864             	
0149   7864 86 00       	ldaA	#00000000b	;select direction (3rd bit = 0)
0150   7866 B7 22 01    	staA 	solenoidAC
0151   7869 B7 22 03    	staA	solenoidBC
0152   786C 86 FF       	ldaA 	#11111111b	;set to output
0153   786E B7 22 00    	staA 	solenoidA
0154   7871 B7 22 02    	staA 	solenoidB
0155   7874 86 04       	ldaA 	#00000100b 	;select data (3rb bit = 1)
0156   7876 B7 22 01    	staA 	solenoidAC
0157   7879 B7 22 03    	staA 	solenoidBC
0158   787C             	
0159   787C             ;
0160   787C             
0161   787C 86 00       	ldaA	#00
0162   787E D7 10       	staB	displayBcd1
0163   7880             	
0164   7880 86 FF       	ldaA	#$FF	
0165   7882 B7 28 00    	staA 	displayStrobe
0166   7885             
0167   7885 86 00       	ldaA	#00
0168   7887 97 07       	staA	strobe
0169   7889 B7 01 68    	staA	displayCol
0170   788C             	
0171   788C CE 00 00    	ldX 	#0
0172   788F DF 50       	stX		curCol
0173   7891             	
0174   7891 86 00       	ldaA	#0
0175   7893 97 52       	staA	curSwitchRowLsb
0176   7895             	
0177   7895             ; fill solenoid status with off
0178   7895 86 FF       	ldaA	#$FF
0179   7897 CE 01 40    	ldX		#solenoid1
0180   789A             lSolDefault:
0181   789A A7 00       	staA	0, X
0182   789C 08          	inX
0183   789D 8C 01 4F    	cpX		#solenoid16
0184   78A0 2F F8       	ble		lSolDefault
0185   78A2             	
0186   78A2             ; empty settle
0187   78A2 86 00       	ldaA	#$00
0188   78A4 CE 01 00    	ldX		#settleRow1
0189   78A7             lSettleDefault:
0190   78A7 A7 00       	staA		0, X
0191   78A9 08          	inX
0192   78AA 8C 08 46    	cpX		#settleRow8 + 7
0193   78AD 2F F8       	ble		lSettleDefault
0194   78AF             	
0195   78AF             ; empty queue
0196   78AF 86 FF       	ldaA	#$FF
0197   78B1 CE 00 60    	ldX		#queue
0198   78B4             lEmptyQueue:
0199   78B4 A7 00       	staA		0, X
0200   78B6 08          	inX
0201   78B7 8C 00 6F    	cpX		#queueLast
0202   78BA 2F F8       	ble		lEmptyQueue
0203   78BC             	
0204   78BC 86 00       	ldaA	#0
0205   78BE B7 01 70    	staA	queueStart
0206   78C1 B7 01 71    	staA	queueEnd
0207   78C4             	
0208   78C4             ; test numbers
0209   78C4 CE 00 11    	ldX		#displayBcd1 + 1
0210   78C7 86 00       	ldaA	#0
0211   78C9             lTestNumbers:
0212   78C9 A7 00       	staA	0, X
0213   78CB 08          	inX
0214   78CC 4C          	incA
0215   78CD 84 07       	andA	#00000111b
0216   78CF 8C 00 1F    	cpX		#displayBcd16
0217   78D2 2F F5       	ble		lTestNumbers
0218   78D4             	
0219   78D4             	
0220   78D4             ; setup complete
0221   78D4 0E          	clI		; enable timer interrupt
0222   78D5             	
0223   78D5             	
0224   78D5             end:
0225   78D5 86 0F       	ldaA	#00001111b
0226   78D7 B4 01 70    	andA	queueStart
0227   78DA             	
0228   78DA             	
0229   78DA 86 08       				ldaA	#1000b	; gameover
0230   78DC B5 01 69    				bitA	state
0231   78DF             				ifne	; in gameover
0231   78DF             
0231   78DF 27 FE       
0232   78E1 86 80       					ldaA #10000000b; 
0233   78E3 95 00       					bitA
0234   78E5             				endif
0234   78E5             
0234   78E5             
0234   78E5             
0234   78E5             
0234   78E5             
0234   78E5~            				endif
0234   78E5~            				endif
0234   78E5             
0234   78E5~            				endif
0234   78E5~            				endif
0234   78E5             
0234   78E0             
0234   78E0 04          
0234   78E1             
0234   78E1             
0234   78E1~            				endif
0234   78E1~            				endif
0234   78E1~            				endif
0234   78E1             
0234   78E5             
0234   78E5~            				endif
0234   78E5~            				endif
0234   78E5             
0235   78E5             				
0236   78E5             skipSwitch:
0237   78E5             				
0238   78E5             	
0239   78E5             				
0240   78E5 7E 78 D5    	jmp		end
0241   78E8 00 00       	.dw 0
0242   78EA 00 00       	.dw 0
0243   78EC 00 00       	.dw 0
0244   78EE 00 00       	.dw 0
0245   78F0 00 00       	.dw 0
0246   78F2             		
0247   78F2             interrupt:	
0248   78F2 7C 00 02    	inc		counter
0249   78F5 86 00       	ldaA	#0
0250   78F7 91 02       	cmpA	counter
0251   78F9 26 25       	bne		counterHandled
0252   78FB 7C 00 03    	inc 	counter2
0253   78FE 86 04       	ldaA	#4
0254   7900 91 03       	cmpA	counter2
0255   7902 26 1C       	bne		counterHandled
0256   7904             	
0257   7904 86 00       	ldaA	#0
0258   7906 97 03       	staA	counter2
0259   7908 86 77       	ldaA	#01110111b
0260   790A 91 10       	cmpA	displayBcd1
0261   790C 27 0A       	beq		on
0262   790E             	
0263   790E 86 F0       	ldaA	#$F0
0264   7910 97 08       	staA	lampRow1
0265   7912 86 77       	ldaA	#01110111b
0266   7914 97 10       	staA	displayBcd1	
0267   7916 20 08       	bra		counterHandled
0268   7918             on:
0269   7918 86 0F       	ldaA	#$0F
0270   791A 97 08       	staA	lampRow1
0271   791C 86 33       	ldaA	#00110011b
0272   791E 97 10       	staA	displayBcd1	
0273   7920             
0274   7920             counterHandled:
0275   7920             ; move switch column
0276   7920 96 07       	ldaA	strobe
0277   7922 B7 30 02    	staA	switchStrobe
0278   7925             	
0279   7925             ; update display 
0280   7925 DE 50       	ldX		curCol
0281   7927 B6 01 68    	ldaA	displayCol
0282   792A C6 FF       	ldaB 	#$FF
0283   792C F7 28 02    	staB	displayBcd
0284   792F B7 28 00    	staA	displayStrobe
0285   7932 85 08       	bitA	#00001000b
0286   7934             	ifeq
0286   7934             
0286   7934 26 FE       
0287   7936 E6 10       		ldaB	displayBcd1, X
0288   7938             	else
0288   7938             
0288   7938             
0288   7938             
0288   7938             
0288   7935             
0288   7935             
0288   7935             
0288   7935~            	else
0288   7935~            	else
0288   7935~            	else
0288   7935~            	else
0288   7935             
0288   7935~            	else
0288   7935~            	else
0288   7935~            	else
0288   7935~            	else
0288   7935             
0288   7935             
0288   7935 04          
0288   7938             
0288   7938 20 FE       
0288   793A             
0288   793A             
0288   793A             
0288   793A~            	else
0288   793A~            	else
0288   793A~            	else
0288   793A~            	else
0288   793A~            	else
0288   793A             
0288   793A~            	else
0288   793A~            	else
0288   793A             
0288   793A~            	else
0288   793A~            	else
0288   793A             
0289   793A E6 18       		ldaB	displayBcd1 + 8, X
0290   793C             	endif
0290   793C             
0290   793C             
0290   793C             
0290   793C             
0290   793C             
0290   793C~            	endif
0290   793C~            	endif
0290   793C             
0290   793C~            	endif
0290   793C~            	endif
0290   793C             
0290   7939             
0290   7939 02          
0290   793A             
0290   793A             
0290   793A~            	endif
0290   793A~            	endif
0290   793A~            	endif
0290   793A             
0290   793C             
0290   793C~            	endif
0290   793C~            	endif
0290   793C             
0291   793C F7 28 02    	staB	displayBcd
0292   793F             	
0293   793F             ; read switches
0294   793F DE 50       	ldX		curCol
0295   7941 B6 30 00    	ldaA	switchRow
0296   7944 16          	tab
0297   7945 A8 20       	eorA	switchRow1, X ; A contains any switches that have changed state
0298   7947             	
0299   7947 D6 52       	ldaB	curSwitchRowLsb 	;	B now contains LSB of callbackTable row addr
0300   7949 D7 01       	staB	temp + 1 			; temp = switch / 2
0301   794B D7 54       	staB	tempX + 1			; tempX = cRAM
0302   794D C6 60       	ldaB	#callbackTable >> 8
0303   794F D7 00       	staB	temp
0304   7951 C6 01       	ldaB	#cRAM >> 8
0305   7953 D7 53       	staB	tempX
0306   7955             	
0307   7955 C6 01       	ldaB	#00000001b ; B is the bit of the current switch in row
0308   7957             	
0309   7957             	; temp now contains the beginning of the row in the callbackTable
0310   7957             swNext:
0311   7957 85 01       	bitA	#00000001b	 ; Z set if switch not different
0312   7959             	ifne		; if bit set, switch different
0312   7959             
0312   7959 27 FE       
0313   795B 36          		pshA ; store changed switches left
0314   795C DE 53       		ldX		tempX
0315   795E A6 00       		ldaA	0, X ; A now how long the switch has left to settle
0316   7960 84 0F       		andA	#00001111b ; need to remove upper F ( sets Z if A = 0)
0317   7962             		ifne 	; A>0 -> settling
0317   7962             
0317   7962 27 FE       
0318   7964 4A          			decA
0319   7965 A7 00       			staA	0, X	; sets Z if now A = 0
0320   7967             			ifeq ; A=0 -> now settled, fire event
0320   7967             
0320   7967 26 FE       
0321   7969             settled:		
0322   7969 DE 50       				ldX		curCol
0323   796B 17          				tBA	; A now the bit in row
0324   796C A8 20       				eorA	switchRow1, X ; toggle bit in row
0325   796E A7 20       				staA	switchRow1, X ; A now state of row
0326   7970             				
0327   7970             				
0328   7970             				
0329   7970             				; todo somehow actually fire it here
0330   7970             				;asl		temp + 1
0331   7970             				;ldX		temp	
0332   7970             				;ldX		0, X
0333   7970             				;jsr		0, X
0334   7970             			endif
0334   7970             
0334   7970             
0334   7970             
0334   7970             
0334   7970             
0334   7970~            			endif
0334   7970~            			endif
0334   7970             
0334   7970~            			endif
0334   7970~            			endif
0334   7970             
0334   7968             
0334   7968 07          
0334   7969             
0334   7969             
0334   7969~            			endif
0334   7969~            			endif
0334   7969~            			endif
0334   7969             
0334   7970             
0334   7970~            			endif
0334   7970~            			endif
0334   7970             
0335   7970             		else ; =0 -> was settled, so now it's not
0335   7970             
0335   7970             
0335   7970             
0335   7970             
0335   7963             
0335   7963             
0335   7963             
0335   7963~            		else ; =0 -> was settled, so now it's not
0335   7963~            		else ; =0 -> was settled, so now it's not
0335   7963~            		else ; =0 -> was settled, so now it's not
0335   7963~            		else ; =0 -> was settled, so now it's not
0335   7963             
0335   7963~            		else ; =0 -> was settled, so now it's not
0335   7963~            		else ; =0 -> was settled, so now it's not
0335   7963~            		else ; =0 -> was settled, so now it's not
0335   7963~            		else ; =0 -> was settled, so now it's not
0335   7963             
0335   7963             
0335   7963 0E          
0335   7970             
0335   7970 20 FE       
0335   7972             
0335   7972             
0335   7972             
0335   7972~            		else ; =0 -> was settled, so now it's not
0335   7972~            		else ; =0 -> was settled, so now it's not
0335   7972~            		else ; =0 -> was settled, so now it's not
0335   7972~            		else ; =0 -> was settled, so now it's not
0335   7972~            		else ; =0 -> was settled, so now it's not
0335   7972             
0335   7972~            		else ; =0 -> was settled, so now it's not
0335   7972~            		else ; =0 -> was settled, so now it's not
0335   7972             
0335   7972~            		else ; =0 -> was settled, so now it's not
0335   7972~            		else ; =0 -> was settled, so now it's not
0335   7972             
0336   7972             			; get the settle time
0337   7972 96 54       			ldaA	tempX + 1
0338   7974 97 01       			staA	temp + 1 	; get temp in sync with tempX LSB
0339   7976 DE 00       			ldX		temp
0340   7978             			
0341   7978             			; temp contains half the address of the callback, so add diff between settleTable and callbackTable
0342   7978 A6 80       			ldaA	settleTable - callbackTable, X ; A has settle settings
0343   797A             			
0344   797A             			; need to get correct 3 bits from switch settings
0345   797A F5 30 00    			bitB	switchRow
0346   797D             			ifne ; switch just turned on
0346   797D             
0346   797D 27 FE       
0347   797F 44          				lsrA
0348   7980 44          				lsrA
0349   7981             			else
0349   7981             
0349   7981             
0349   7981             
0349   7981             
0349   797E             
0349   797E             
0349   797E             
0349   797E~            			else
0349   797E~            			else
0349   797E~            			else
0349   797E~            			else
0349   797E             
0349   797E~            			else
0349   797E~            			else
0349   797E~            			else
0349   797E~            			else
0349   797E             
0349   797E             
0349   797E 04          
0349   7981             
0349   7981 20 FE       
0349   7983             
0349   7983             
0349   7983             
0349   7983~            			else
0349   7983~            			else
0349   7983~            			else
0349   7983~            			else
0349   7983~            			else
0349   7983             
0349   7983~            			else
0349   7983~            			else
0349   7983             
0349   7983~            			else
0349   7983~            			else
0349   7983             
0350   7983 48          				aslA
0351   7984             			endif
0351   7984             
0351   7984             
0351   7984             
0351   7984             
0351   7984             
0351   7984~            			endif
0351   7984~            			endif
0351   7984             
0351   7984~            			endif
0351   7984~            			endif
0351   7984             
0351   7982             
0351   7982 01          
0351   7983             
0351   7983             
0351   7983~            			endif
0351   7983~            			endif
0351   7983~            			endif
0351   7983             
0351   7984             
0351   7984~            			endif
0351   7984~            			endif
0351   7984             
0352   7984 84 0E       			andA	#1110b ; A now has 3 bit settle time * 2
0353   7986             						
0354   7986 DE 53       			ldX		tempX
0355   7988 A7 00       			staA	0, X		; start settling	
0356   798A 27 DD       			beq		settled		; quick out for 0 settle
0357   798C             		endif
0357   798C             
0357   798C             
0357   798C             
0357   798C             
0357   798C             
0357   798C~            		endif
0357   798C~            		endif
0357   798C             
0357   798C~            		endif
0357   798C~            		endif
0357   798C             
0357   7971             
0357   7971 1A          
0357   7972             
0357   7972             
0357   7972~            		endif
0357   7972~            		endif
0357   7972~            		endif
0357   7972             
0357   798C             
0357   798C~            		endif
0357   798C~            		endif
0357   798C             
0358   798C             			
0359   798C 32          		pulA
0360   798D             	endif
0360   798D             
0360   798D             
0360   798D             
0360   798D             
0360   798D             
0360   798D~            	endif
0360   798D~            	endif
0360   798D             
0360   798D~            	endif
0360   798D~            	endif
0360   798D             
0360   795A             
0360   795A 32          
0360   795B             
0360   795B             
0360   795B~            	endif
0360   795B~            	endif
0360   795B~            	endif
0360   795B             
0360   798D             
0360   798D~            	endif
0360   798D~            	endif
0360   798D             
0361   798D 7C 00 54    	inc tempX + 1
0362   7990 58          	aslB
0363   7991 44          	lsrA			; pop lowest bit off, set Z if A is empty
0364   7992 26 C3       	bne		swNext 	; more 'switched' bits, keep processing 
0365   7994             	
0366   7994             	
0367   7994             ; update lamps
0368   7994 DE 50       	ldX		curCol
0369   7996 86 FF       	ldaA	#$FF	;lamp row is inverted
0370   7998 B7 24 00    	staA	lampRow
0371   799B 96 07       	ldaA	strobe
0372   799D B7 24 02    	staA	lampStrobe
0373   79A0 A6 20       	ldaA	switchRow1, X
0374   79A2 B7 24 00    	staA	lampRow
0375   79A5 86 00       	ldaA	#00
0376   79A7             
0377   79A7             ; update solenoids
0378   79A7             	; if a solenoid is set to <254, --
0379   79A7             	; if =255, off, otherwise on
0380   79A7             	; leave it at 254
0381   79A7             	
0382   79A7 7C 00 50    	inc		curCol	; indexed can't use base >255, so temp inc X by 255 (1 MSB)
0383   79AA 86 FE       	ldaA	#254
0384   79AC DE 50       	ldX		curCol
0385   79AE E6 40       	ldaB	solenoid1 - cRAM, X
0386   79B0 A1 40       	cmpA	solenoid1 - cRAM, X
0387   79B2             	ifge 	; solenoid <=254, turn on
0387   79B2             
0387   79B2 25 FE       
0388   79B4             		ifgt	; solenoid < 254, decrement
0388   79B4             
0388   79B4 23 FE       
0389   79B6 6A 40       			dec		solenoid1 - cRAM, X
0390   79B8             		endif
0390   79B8             
0390   79B8             
0390   79B8             
0390   79B8             
0390   79B8             
0390   79B8~            		endif
0390   79B8~            		endif
0390   79B8             
0390   79B8~            		endif
0390   79B8~            		endif
0390   79B8             
0390   79B5             
0390   79B5 02          
0390   79B6             
0390   79B6             
0390   79B6~            		endif
0390   79B6~            		endif
0390   79B6~            		endif
0390   79B6             
0390   79B8             
0390   79B8~            		endif
0390   79B8~            		endif
0390   79B8             
0391   79B8 0D          		sec
0392   79B9             	else
0392   79B9             
0392   79B9             
0392   79B9             
0392   79B9             
0392   79B3             
0392   79B3             
0392   79B3             
0392   79B3~            	else
0392   79B3~            	else
0392   79B3~            	else
0392   79B3~            	else
0392   79B3             
0392   79B3~            	else
0392   79B3~            	else
0392   79B3~            	else
0392   79B3~            	else
0392   79B3             
0392   79B3             
0392   79B3 07          
0392   79B9             
0392   79B9 20 FE       
0392   79BB             
0392   79BB             
0392   79BB             
0392   79BB~            	else
0392   79BB~            	else
0392   79BB~            	else
0392   79BB~            	else
0392   79BB~            	else
0392   79BB             
0392   79BB~            	else
0392   79BB~            	else
0392   79BB             
0392   79BB~            	else
0392   79BB~            	else
0392   79BB             
0393   79BB 0C          		clc
0394   79BC             	endif
0394   79BC             
0394   79BC             
0394   79BC             
0394   79BC             
0394   79BC             
0394   79BC~            	endif
0394   79BC~            	endif
0394   79BC             
0394   79BC~            	endif
0394   79BC~            	endif
0394   79BC             
0394   79BA             
0394   79BA 01          
0394   79BB             
0394   79BB             
0394   79BB~            	endif
0394   79BB~            	endif
0394   79BB~            	endif
0394   79BB             
0394   79BC             
0394   79BC~            	endif
0394   79BC~            	endif
0394   79BC             
0395   79BC 76 00 28    	ror		solAStatus
0396   79BF A1 48       	cmpA	solenoid9 - cRAM, X
0397   79C1             	ifge 	; solenoid <=254, turn on
0397   79C1             
0397   79C1 25 FE       
0398   79C3             		ifgt	; solenoid < 254, decrement
0398   79C3             
0398   79C3 23 FE       
0399   79C5 6A 48       			dec		solenoid9 - cRAM, X
0400   79C7             		endif
0400   79C7             
0400   79C7             
0400   79C7             
0400   79C7             
0400   79C7             
0400   79C7~            		endif
0400   79C7~            		endif
0400   79C7             
0400   79C7~            		endif
0400   79C7~            		endif
0400   79C7             
0400   79C4             
0400   79C4 02          
0400   79C5             
0400   79C5             
0400   79C5~            		endif
0400   79C5~            		endif
0400   79C5~            		endif
0400   79C5             
0400   79C7             
0400   79C7~            		endif
0400   79C7~            		endif
0400   79C7             
0401   79C7 0D          		sec
0402   79C8             	else
0402   79C8             
0402   79C8             
0402   79C8             
0402   79C8             
0402   79C2             
0402   79C2             
0402   79C2             
0402   79C2~            	else
0402   79C2~            	else
0402   79C2~            	else
0402   79C2~            	else
0402   79C2             
0402   79C2~            	else
0402   79C2~            	else
0402   79C2~            	else
0402   79C2~            	else
0402   79C2             
0402   79C2             
0402   79C2 07          
0402   79C8             
0402   79C8 20 FE       
0402   79CA             
0402   79CA             
0402   79CA             
0402   79CA~            	else
0402   79CA~            	else
0402   79CA~            	else
0402   79CA~            	else
0402   79CA~            	else
0402   79CA             
0402   79CA~            	else
0402   79CA~            	else
0402   79CA             
0402   79CA~            	else
0402   79CA~            	else
0402   79CA             
0403   79CA 0C          		clc
0404   79CB             	endif
0404   79CB             
0404   79CB             
0404   79CB             
0404   79CB             
0404   79CB             
0404   79CB~            	endif
0404   79CB~            	endif
0404   79CB             
0404   79CB~            	endif
0404   79CB~            	endif
0404   79CB             
0404   79C9             
0404   79C9 01          
0404   79CA             
0404   79CA             
0404   79CA~            	endif
0404   79CA~            	endif
0404   79CA~            	endif
0404   79CA             
0404   79CB             
0404   79CB~            	endif
0404   79CB~            	endif
0404   79CB             
0405   79CB 76 00 29    	ror		solBStatus
0406   79CE 7A 00 50    	dec		curCol
0407   79D1             	
0408   79D1             ; update strobe	
0409   79D1 DE 50       	ldX		curCol
0410   79D3 08          	inX 	
0411   79D4 86 08       	ldaA	#8 	; pitch
0412   79D6 9B 52       	addA	curSwitchRowLsb
0413   79D8 97 52       	staA	curSwitchRowLsb
0414   79DA 78 00 07    	asl		strobe
0415   79DD 7C 01 68    	inc		displayCol
0416   79E0 86 00       	ldaA	#0
0417   79E2 91 07       	cmpA	strobe ; strobe done?  reset
0418   79E4             	ifeq		
0418   79E4             
0418   79E4 26 FE       
0419   79E6 96 28       		ldaA	solAStatus
0420   79E8 B7 22 00    		staA	solenoidA
0421   79EB 96 29       		ldaA	solBStatus
0422   79ED B7 22 02    		staA	solenoidB
0423   79F0             	
0424   79F0 86 01       		ldaA	#00000001b
0425   79F2 97 07       		staA	strobe
0426   79F4             		
0427   79F4 CE 00 00    		ldX 	#0
0428   79F7             		
0429   79F7 86 00       		ldaA	#0
0430   79F9 97 52       		staA	curSwitchRowLsb
0431   79FB 97 28       		staA	solAStatus
0432   79FD 97 29       		staA	solBStatus
0433   79FF             		
0434   79FF F6 01 68    		ldaB	displayCol	; reset display col only if it's > 7 
0435   7A02 C1 F8       		cmpB	#$F8	; since it needs to count to 15 instead of 7
0436   7A04             		ifgt
0436   7A04             
0436   7A04 23 FE       
0437   7A06 B7 01 68    			staA	displayCol
0438   7A09             		endif
0438   7A09             
0438   7A09             
0438   7A09             
0438   7A09             
0438   7A09             
0438   7A09~            		endif
0438   7A09~            		endif
0438   7A09             
0438   7A09~            		endif
0438   7A09~            		endif
0438   7A09             
0438   7A05             
0438   7A05 03          
0438   7A06             
0438   7A06             
0438   7A06~            		endif
0438   7A06~            		endif
0438   7A06~            		endif
0438   7A06             
0438   7A09             
0438   7A09~            		endif
0438   7A09~            		endif
0438   7A09             
0439   7A09             	endif
0439   7A09             
0439   7A09             
0439   7A09             
0439   7A09             
0439   7A09             
0439   7A09~            	endif
0439   7A09~            	endif
0439   7A09             
0439   7A09~            	endif
0439   7A09~            	endif
0439   7A09             
0439   79E5             
0439   79E5 23          
0439   79E6             
0439   79E6             
0439   79E6~            	endif
0439   79E6~            	endif
0439   79E6~            	endif
0439   79E6             
0439   7A09             
0439   7A09~            	endif
0439   7A09~            	endif
0439   7A09             
0440   7A09             	
0441   7A09 DF 50       	stX		curCol
0442   7A0B 3B          	rti
0443   7A0C             
0444   7FF8             pointers: 	.org $7FF8  	
0445   7FF8             	.msfirst
0446   7FF8 78 F2       	.dw interrupt			
0447   7FFA 78 F2       	.dw interrupt			
0448   7FFC 78 F2       	.dw interrupt			
0449   7FFE 78 00       	.dw main
0450   8000             	
0451   8000             	
0452   8000             	.endtasm: Number of errors = 0
